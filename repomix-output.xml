This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
index.html
package.json
public/audio/montiel.weba
public/models/arco.glb
public/models/arquero.glb
public/models/elshenawy.glb
public/models/jugador.glb
public/models/pelota.glb
public/vite.svg
README.md
src/counter.js
src/experience/Assets.js
src/experience/Audio.js
src/experience/GestureManager.js
src/experience/GoalkeeperAI_backup.js
src/experience/GoalkeeperAI.js
src/experience/Input.js
src/experience/KickGestureManager.js
src/experience/SceneManager.js
src/experience/ShotModel.js
src/experience/Stadium.js
src/experience/States.js
src/experience/UI.js
src/javascript.svg
src/main.js
src/style.css
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/counter.js">
export function setupCounter(element) {
  let counter = 0
  const setCounter = (count) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}
</file>

<file path="src/experience/GestureManager.js">
import EventEmitter from 'eventemitter3';

export default class GestureManager extends EventEmitter {
    constructor() {
        super();
        this.hands = null;
        this.camera = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.canvasCtx = null;
        
        this.isPointing = false;
        this.isFistClosed = false;
        this.wasChargingPower = false;
        
        this.pointingTarget = { x: 0.5, y: 0.5 };
        this.enabled = false;
        
        // Referencias a las librer√≠as MediaPipe
        this.MediaPipeHands = null;
        this.MediaPipeCamera = null;
        this.MediaPipeDrawing = null;
    }

    async init() {
        console.log('üñêÔ∏è Initializing GestureManager...');
        
        this.createVideoElements();
        
        try {
            // Cargar TODAS las librer√≠as antes de continuar
            await this.loadAllMediaPipeLibraries();
            
            // Iniciar c√°mara
            await this.startCamera();
            
            console.log('‚úÖ GestureManager initialized successfully');
            this.emit('ready');
            return true;
        } catch (error) {
            console.error('‚ùå Error initializing GestureManager:', error);
            this.emit('error', error);
            this.updateStatus('‚ùå Error: ' + error.message);
            return false;
        }
    }

    createVideoElements() {
        const container = document.createElement('div');
        container.id = 'gesture-camera-container';
        container.style.cssText = `
            position: fixed;
            top: 10px;
            left: 10px;
            width: 320px;
            height: 240px;
            border: 2px solid #fff;
            border-radius: 8px;
            overflow: hidden;
            z-index: 1000;
            background: #000;
        `;
        
        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = `
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        `;
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        
        this.canvasElement = document.createElement('canvas');
        this.canvasElement.width = 320;
        this.canvasElement.height = 240;
        this.canvasElement.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        `;
        this.canvasCtx = this.canvasElement.getContext('2d');
        
        const statusDiv = document.createElement('div');
        statusDiv.id = 'gesture-status';
        statusDiv.style.cssText = `
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 5px;
            font-size: 12px;
            border-radius: 4px;
            text-align: center;
        `;
        statusDiv.textContent = 'Inicializando...';
        
        container.appendChild(this.videoElement);
        container.appendChild(this.canvasElement);
        container.appendChild(statusDiv);
        document.body.appendChild(container);
        
        this.statusDiv = statusDiv;
    }

    async loadAllMediaPipeLibraries() {
        console.log('üì¶ Loading MediaPipe libraries...');
        
        // Cargar scripts en orden y esperar a que cada uno termine
        await this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js');
        await this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');
        await this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js');
        
        // Verificar que las librer√≠as se cargaron
        if (typeof window.Hands === 'undefined') {
            throw new Error('MediaPipe Hands no se carg√≥ correctamente');
        }
        if (typeof window.Camera === 'undefined') {
            throw new Error('MediaPipe Camera no se carg√≥ correctamente');
        }
        
        console.log('‚úÖ All MediaPipe libraries loaded');
        
        // Guardar referencias
        this.MediaPipeHands = window.Hands;
        this.MediaPipeCamera = window.Camera;
        this.MediaPipeDrawing = {
            drawConnectors: window.drawConnectors,
            drawLandmarks: window.drawLandmarks,
            HAND_CONNECTIONS: window.HAND_CONNECTIONS
        };
        
        // Ahora inicializar MediaPipe Hands
        this.initMediaPipe();
    }

    loadScript(src) {
        return new Promise((resolve, reject) => {
            // Verificar si ya est√° cargado
            const existing = document.querySelector(`script[src="${src}"]`);
            if (existing) {
                console.log(`Script ya existe: ${src}`);
                resolve();
                return;
            }
            
            const script = document.createElement('script');
            script.src = src;
            script.onload = () => {
                console.log(`‚úÖ Loaded: ${src}`);
                resolve();
            };
            script.onerror = () => {
                console.error(`‚ùå Failed to load: ${src}`);
                reject(new Error(`Failed to load ${src}`));
            };
            document.head.appendChild(script);
        });
    }

    initMediaPipe() {
        console.log('üîß Initializing MediaPipe Hands...');
        
        this.hands = new this.MediaPipeHands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        
        this.hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        this.hands.onResults((results) => this.onResults(results));
        
        console.log('‚úÖ MediaPipe Hands initialized');
    }

    async startCamera() {
        console.log('üìπ Starting camera...');
        this.updateStatus('üìπ Solicitando c√°mara...');
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    width: 320, 
                    height: 240,
                    facingMode: 'user'
                }
            });
            
            console.log('‚úÖ Camera permission granted');
            this.videoElement.srcObject = stream;
            
            // Esperar a que el video est√© listo
            await new Promise((resolve) => {
                this.videoElement.onloadedmetadata = () => {
                    console.log('‚úÖ Video metadata loaded');
                    resolve();
                };
            });
            
            this.camera = new this.MediaPipeCamera(this.videoElement, {
                onFrame: async () => {
                    if (this.enabled && this.hands) {
                        await this.hands.send({ image: this.videoElement });
                    }
                },
                width: 320,
                height: 240
            });
            
            this.camera.start();
            console.log('‚úÖ Camera started');
            this.updateStatus('‚úÖ C√°mara activa');
            
        } catch (error) {
            console.error('‚ùå Camera error:', error);
            this.updateStatus('‚ùå No se pudo acceder a la c√°mara');
            throw error;
        }
    }

    onResults(results) {
        this.canvasCtx.save();
        this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
        
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // Dibujar conexiones y landmarks
            if (this.MediaPipeDrawing.drawConnectors) {
                this.MediaPipeDrawing.drawConnectors(
                    this.canvasCtx, 
                    landmarks, 
                    this.MediaPipeDrawing.HAND_CONNECTIONS, 
                    {color: '#00FF00', lineWidth: 2}
                );
                this.MediaPipeDrawing.drawLandmarks(
                    this.canvasCtx, 
                    landmarks, 
                    {color: '#FF0000', lineWidth: 1, radius: 2}
                );
            }
            
            const gesture = this.detectGesture(landmarks);
            this.handleGesture(gesture, landmarks);
        } else {
            this.updateStatus('‚ùå No se detecta mano');
        }
        
        this.canvasCtx.restore();
    }

    detectGesture(landmarks) {
        const indexTip = landmarks[8];
        const indexPip = landmarks[6];
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];
        
        const indexExtended = indexTip.y < indexPip.y;
        const middleClosed = middleTip.y > landmarks[10].y;
        const ringClosed = ringTip.y > landmarks[14].y;
        const pinkyClosed = pinkyTip.y > landmarks[18].y;
        
        const indexClosed = indexTip.y > indexPip.y;
        const allFingersClosed = indexClosed && middleClosed && ringClosed && pinkyClosed;
        
        if (indexExtended && middleClosed && ringClosed && pinkyClosed) {
            return {
                type: 'POINTING',
                target: { x: indexTip.x, y: indexTip.y }
            };
        } else if (allFingersClosed) {
            return { type: 'FIST' };
        } else {
            return { type: 'OPEN' };
        }
    }

    handleGesture(gesture, landmarks) {
        const prevFist = this.isFistClosed;
        
        this.isPointing = gesture.type === 'POINTING';
        this.isFistClosed = gesture.type === 'FIST';
        
        if (this.isPointing) {
            this.pointingTarget = gesture.target;
            this.emit('pointing', this.pointingTarget);
            this.updateStatus('üëÜ Apuntando');
        } else if (this.isFistClosed) {
            if (!prevFist && !this.wasChargingPower) {
                this.wasChargingPower = true;
                this.emit('charge-start');
                this.updateStatus('üëä Cargando potencia...');
            } else if (this.wasChargingPower) {
                this.emit('charging');
            }
        } else {
            if (this.wasChargingPower) {
                this.wasChargingPower = false;
                this.emit('shoot');
                this.updateStatus('‚öΩ ¬°DISPARO!');
            } else {
                this.updateStatus('‚úã Mano detectada');
            }
        }
    }

    updateStatus(text) {
        if (this.statusDiv) {
            this.statusDiv.textContent = text;
        }
    }

    enable() {
        this.enabled = true;
        console.log('üñêÔ∏è Gesture control enabled');
    }

    disable() {
        this.enabled = false;
        this.isPointing = false;
        this.isFistClosed = false;
        this.wasChargingPower = false;
        console.log('üñêÔ∏è Gesture control disabled');
    }

    getPointingTarget() {
        return this.pointingTarget;
    }

    destroy() {
        if (this.camera) {
            this.camera.stop();
        }
        
        if (this.videoElement && this.videoElement.srcObject) {
            const tracks = this.videoElement.srcObject.getTracks();
            tracks.forEach(track => track.stop());
        }
        
        const container = document.getElementById('gesture-camera-container');
        if (container) {
            container.remove();
        }
    }
}
</file>

<file path="src/experience/KickGestureManager.js">
import EventEmitter from 'eventemitter3';

export default class KickGestureManager extends EventEmitter {
    constructor() {
        super();
        this.pose = null;
        this.camera = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.canvasCtx = null;
        
        // Estados del pateo REDISE√ëADOS
        this.kickTarget = { x: 0.5, y: 0.5 };
        this.kickPower = 0;
        this.maxFootHeight = 0;
        
        // Control de fases
        this.isKneeFlexed = false;      // Rodilla flexionada (pie hacia atr√°s)
        this.wasKneeFlexed = false;     // Estaba flexionada
        this.isLegExtended = false;     // Pierna extendida (disparo)
        
        // Control de cooldown
        this.shotCooldown = false;
        this.COOLDOWN_TIME = 2000;
        
        // Umbrales mejorados
        this.KNEE_FLEX_THRESHOLD = 0.15;        // Flexi√≥n de rodilla
        this.LEG_EXTENSION_VELOCITY = 0.04;     // Velocidad de extensi√≥n para disparar
        this.MAX_FLEX_DISTANCE = 0.4;           // M√°xima distancia de flexi√≥n
        
        // Tracking de posici√≥n del pie
        this.previousAnklePos = null;
        this.ankleHistory = [];
        this.historySize = 8;
        this.previousKneePos = null;
        
        this.enabled = false;
        
        // Referencias a MediaPipe
        this.MediaPipePose = null;
        this.MediaPipeCamera = null;
        this.MediaPipeDrawing = null;
        
        // Calibraci√≥n autom√°tica
        this.calibrationFrames = 0;
        this.baselineAnkleZ = null;
        this.baselineKneeY = null;
        
        // DEBUG
        this.debugCounter = 0;
    }

    async init() {
        console.log('ü¶∂ Initializing REDISE√ëADO KickGestureManager...');
        
        this.createVideoElements();
        
        try {
            await this.loadAllMediaPipeLibraries();
            await this.startCamera();
            
            console.log('‚úÖ KickGestureManager initialized successfully');
            this.emit('ready');
            return true;
        } catch (error) {
            console.error('‚ùå Error initializing KickGestureManager:', error);
            this.emit('error', error);
            this.updateStatus('‚ùå Error: ' + error.message);
            return false;
        }
    }

    createVideoElements() {
        const existing = document.getElementById('kick-camera-container');
        if (existing) {
            existing.remove();
        }

        const container = document.createElement('div');
        container.id = 'kick-camera-container';
        container.style.cssText = `
            position: fixed;
            top: 10px;
            left: 10px;
            width: 480px;
            height: 360px;
            border: 3px solid #00ff00;
            border-radius: 8px;
            overflow: hidden;
            z-index: 1000;
            background: #000;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
        `;

        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        `;
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        this.videoElement.muted = true; // necesario para autoplay en la mayor√≠a de los navegadores
        this.videoElement.setAttribute('muted', '');

        this.canvasElement = document.createElement('canvas');
        this.canvasElement.width = 480;
        this.canvasElement.height = 360;
        this.canvasElement.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            pointer-events: none;
        `;
        this.canvasCtx = this.canvasElement.getContext('2d');

        const statusDiv = document.createElement('div');
        statusDiv.id = 'kick-status';
        statusDiv.style.cssText = `
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            padding: 8px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 4px;
            text-align: center;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #0f0;
        `;
        statusDiv.textContent = 'Inicializando...';

        // Barra de potencia (ahora creada correctamente)
        const powerBar = document.createElement('div');
        powerBar.id = 'kick-power-bar';
        powerBar.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 120px;
            background: rgba(255,255,255,0.06);
            border: 2px solid rgba(0,255,0,0.2);
            border-radius: 6px;
            overflow: hidden;
        `;

        const powerFill = document.createElement('div');
        powerFill.id = 'kick-power-fill';
        powerFill.style.cssText = `
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(180deg, #0f0, #ff0);
            transition: height 120ms linear;
        `;

        const powerLabel = document.createElement('div');
        powerLabel.id = 'kick-power-label';
        powerLabel.style.cssText = `
            position: absolute;
            top: -22px;
            left: -10px;
            width: 60px;
            text-align: center;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        `;
        powerLabel.textContent = '0%';

        powerBar.appendChild(powerFill);
        powerBar.appendChild(powerLabel);

        const movementIndicator = document.createElement('div');
        movementIndicator.id = 'movement-indicator';
        movementIndicator.style.cssText = `
            position: absolute;
            top: 270px;
            right: 10px;
            width: 120px;
            padding: 12px;
            background: rgba(0,0,0,0.8);
            border: 3px solid #0f0;
            border-radius: 8px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 0 10px rgba(0,255,0,0.3);
            pointer-events: none;
        `;
        movementIndicator.innerHTML = 'ü•Ö<br>LISTO';

        container.appendChild(this.videoElement);
        container.appendChild(this.canvasElement);
        container.appendChild(statusDiv);
        container.appendChild(powerBar);
        container.appendChild(movementIndicator);
        document.body.appendChild(container);

        this.statusDiv = statusDiv;
        this.powerFill = powerFill;
        this.powerLabel = powerLabel;
        this.movementIndicator = movementIndicator;
    }

    async loadAllMediaPipeLibraries() {
        console.log('üì¶ Loading MediaPipe Pose libraries...');
        
        await this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js');
        await this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');
        await this.loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js');
        
        if (typeof window.Pose === 'undefined') {
            throw new Error('MediaPipe Pose no se carg√≥ correctamente');
        }
        if (typeof window.Camera === 'undefined') {
            throw new Error('MediaPipe Camera no se carg√≥ correctamente');
        }
        
        console.log('‚úÖ All MediaPipe Pose libraries loaded');
        
        this.MediaPipePose = window.Pose;
        this.MediaPipeCamera = window.Camera;
        this.MediaPipeDrawing = {
            drawConnectors: window.drawConnectors,
            drawLandmarks: window.drawLandmarks,
            POSE_CONNECTIONS: window.POSE_CONNECTIONS
        };
        
        this.initMediaPipe();
    }

    loadScript(src) {
        return new Promise((resolve, reject) => {
            const existing = document.querySelector(`script[src="${src}"]`);
            if (existing) {
                console.log(`Script ya existe: ${src}`);
                resolve();
                return;
            }
            
            const script = document.createElement('script');
            script.src = src;
            script.onload = () => {
                console.log(`‚úÖ Loaded: ${src}`);
                resolve();
            };
            script.onerror = () => {
                console.error(`‚ùå Failed to load: ${src}`);
                reject(new Error(`Failed to load ${src}`));
            };
            document.head.appendChild(script);
        });
    }

    initMediaPipe() {
        console.log('üîß Initializing MediaPipe Pose...');
        
        this.pose = new this.MediaPipePose({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }
        });
        
        this.pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        this.pose.onResults((results) => this.onResults(results));
        
        console.log('‚úÖ MediaPipe Pose initialized');
    }

    async startCamera() {
        console.log('üìπ Starting camera...');
        this.updateStatus('üìπ Solicitando c√°mara...');
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    width: 640,
                    height: 480,
                    facingMode: 'user'
                }
            });
            
            console.log('‚úÖ Camera permission granted');
            this.videoElement.srcObject = stream;
            
            await new Promise((resolve) => {
                this.videoElement.onloadedmetadata = () => {
                    console.log('‚úÖ Video metadata loaded');
                    resolve();
                };
            });
            
            this.camera = new this.MediaPipeCamera(this.videoElement, {
                onFrame: async () => {
                    if (this.enabled && this.pose) {
                        await this.pose.send({ image: this.videoElement });
                    }
                },
                width: 640,
                height: 480
            });
            
            this.camera.start();
            console.log('‚úÖ Camera started');
            this.updateStatus('‚úÖ ¬°Posici√≥nate de frente! Levanta y baja tu pierna derecha');
            
        } catch (error) {
            console.error('‚ùå Camera error:', error);
            this.updateStatus('‚ùå No se pudo acceder a la c√°mara');
            throw error;
        }
    }

    onResults(results) {
        this.canvasCtx.save();
        this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
        
        if (results.poseLandmarks) {
            const landmarks = results.poseLandmarks;
            
            // Calibraci√≥n autom√°tica
            if (this.calibrationFrames < 30) {
                this.calibrate(landmarks);
                this.calibrationFrames++;
                this.updateStatus(`üìä Calibrando... ${Math.floor(this.calibrationFrames/30*100)}%`);
                return;
            }
            
            // Dibujar esqueleto
            if (this.MediaPipeDrawing.drawConnectors) {
                this.MediaPipeDrawing.drawConnectors(
                    this.canvasCtx, 
                    landmarks, 
                    this.MediaPipeDrawing.POSE_CONNECTIONS, 
                    {color: '#00FF00', lineWidth: 2}
                );
                this.MediaPipeDrawing.drawLandmarks(
                    this.canvasCtx, 
                    landmarks, 
                    {color: '#FF0000', lineWidth: 1, radius: 3}
                );
            }
            
            // Destacar pierna derecha
            this.highlightKickingLeg(landmarks);
            
            // Detectar gesto de pateo
            const kickData = this.detectKickGesture(landmarks);
            this.handleKickGesture(kickData, landmarks);
            
        } else {
            this.updateStatus('‚ùå No se detecta cuerpo - Al√©jate un poco');
            this.resetKickState();
        }
        
        this.canvasCtx.restore();
    }

    calibrate(landmarks) {
        const RIGHT_HIP = 24;
        const RIGHT_KNEE = 26;
        const RIGHT_ANKLE = 28;
        
        const hip = landmarks[RIGHT_HIP];
        const knee = landmarks[RIGHT_KNEE];
        const ankle = landmarks[RIGHT_ANKLE];
        
        if (hip && hip.visibility > 0.5 && knee && knee.visibility > 0.5 && ankle && ankle.visibility > 0.5) {
            if (!this.baselineKneeY) {
                this.baselineKneeY = knee.y;
            } else {
                this.baselineKneeY = this.baselineKneeY * 0.9 + knee.y * 0.1;
            }
            
            if (!this.baselineAnkleZ) {
                this.baselineAnkleZ = ankle.z;
            } else {
                this.baselineAnkleZ = this.baselineAnkleZ * 0.9 + ankle.z * 0.1;
            }
        }
    }

    highlightKickingLeg(landmarks) {
        const RIGHT_HIP = 24;
        const RIGHT_KNEE = 26;
        const RIGHT_ANKLE = 28;
        const RIGHT_FOOT = 32;
        
        const hip = landmarks[RIGHT_HIP];
        const knee = landmarks[RIGHT_KNEE];
        const ankle = landmarks[RIGHT_ANKLE];
        const foot = landmarks[RIGHT_FOOT];
        
        let legColor = '#00FFFF';
        if (this.isKneeFlexed) {
            legColor = '#FFFF00';
        }
        if (this.shotCooldown) {
            legColor = '#FF0000';
        }
        
        this.canvasCtx.strokeStyle = legColor;
        this.canvasCtx.lineWidth = 6;
        this.canvasCtx.beginPath();
        
        this.canvasCtx.moveTo(hip.x * this.canvasElement.width, hip.y * this.canvasElement.height);
        this.canvasCtx.lineTo(knee.x * this.canvasElement.width, knee.y * this.canvasElement.height);
        this.canvasCtx.lineTo(ankle.x * this.canvasElement.width, ankle.y * this.canvasElement.height);
        this.canvasCtx.lineTo(foot.x * this.canvasElement.width, foot.y * this.canvasElement.height);
        
        this.canvasCtx.stroke();
        
        // Mostrar flexi√≥n actual
        if (this.baselineKneeY) {
            const kneeFlexion = (this.baselineKneeY - knee.y) * 100;
            this.canvasCtx.fillStyle = '#FFFFFF';
            this.canvasCtx.font = 'bold 16px Courier New';
            this.canvasCtx.fillText(
                `Flexi√≥n: ${kneeFlexion.toFixed(0)}%`, 
                knee.x * this.canvasElement.width + 15, 
                knee.y * this.canvasElement.height
            );
        }
    }

    detectKickGesture(landmarks) {
        const RIGHT_ANKLE = 28;
        const RIGHT_KNEE = 26;
        const RIGHT_HIP = 24;
        
        const ankle = landmarks[RIGHT_ANKLE];
        const knee = landmarks[RIGHT_KNEE];
        const hip = landmarks[RIGHT_HIP];
        
        if (!ankle.visibility || ankle.visibility < 0.5 || !knee.visibility || knee.visibility < 0.5) {
            this.previousAnklePos = null;
            this.ankleHistory = [];
            return { notVisible: true };
        }
        
        // Calcular flexi√≥n de rodilla
        const kneeFlexion = (this.baselineKneeY || knee.y) - knee.y;
        const isKneeFlexed = kneeFlexion > this.KNEE_FLEX_THRESHOLD;
        
        // Calcular velocidad vertical del tobillo (para detectar extensi√≥n)
        this.ankleHistory.push({ x: ankle.x, y: ankle.y, z: ankle.z, timestamp: Date.now() });
        if (this.ankleHistory.length > this.historySize) {
            this.ankleHistory.shift();
        }
        
        let verticalVelocity = 0;
        let isExtending = false;
        
        if (this.ankleHistory.length >= 5) {
            const recent = this.ankleHistory[this.ankleHistory.length - 1];
            const old = this.ankleHistory[Math.max(0, this.ankleHistory.length - 5)];
            const timeDiff = (recent.timestamp - old.timestamp) / 1000;
            
            if (timeDiff > 0) {
                verticalVelocity = (old.y - recent.y) / timeDiff; // Positivo = hacia arriba
                isExtending = verticalVelocity > this.LEG_EXTENSION_VELOCITY;
            }
        }
        
        this.previousAnklePos = { x: ankle.x, y: ankle.y, z: ankle.z };
        
        return {
            isKneeFlexed,
            kneeFlexion,
            anklePos: ankle,
            verticalVelocity,
            isExtending,
            notVisible: false
        };
    }

    handleKickGesture(kickData, landmarks) {
        if (!this.enabled || kickData.notVisible || this.shotCooldown) {
            return;
        }
        
        const { isKneeFlexed, kneeFlexion, anklePos, verticalVelocity, isExtending } = kickData;
        
        // FASE 1: RODILLA FLEXIONADA - CARGAR
        if (isKneeFlexed && !this.wasKneeFlexed) {
            console.log('‚¨ÜÔ∏è RODILLA FLEXIONADA - Iniciando carga');
            this.emit('charge-start');
            this.isKneeFlexed = true;
            this.wasKneeFlexed = true;
            
            if (this.movementIndicator) {
                this.movementIndicator.innerHTML = '‚¨ÜÔ∏è<br>CARGANDO';
                this.movementIndicator.style.borderColor = '#ffff00';
            }
            this.updateStatus('üéØ Flexiona la rodilla mientras apuntas con tu pie');
        }
        
        // DURANTE CARGA: Detectar posici√≥n horizontal del pie (izquierda/derecha)
        if (isKneeFlexed && this.wasKneeFlexed) {
            this.kickPower = Math.min(1.0, kneeFlexion / this.MAX_FLEX_DISTANCE);
            this.updatePowerBar(this.kickPower * 100);
            
            // Calcular apuntado basado en posici√≥n horizontal del tobillo
            const targetX = anklePos.x; // 0 = izquierda, 1 = derecha
            this.kickTarget = { x: targetX, y: 0.5 };
            
            this.emit('pointing', this.kickTarget);
            this.emit('charging', this.kickPower);
            
            const powerPercent = Math.floor(this.kickPower * 100);
            this.updateStatus(`‚ö° POTENCIA: ${powerPercent}% | Apunta con tu pie | ¬°Extiende para disparar!`);
        }
        
        // FASE 2: EXTENSI√ìN R√ÅPIDA - DISPARAR
        if (!isKneeFlexed && this.wasKneeFlexed && isExtending) {
            const finalPower = Math.max(0.3, this.kickPower);
            
            console.log(`‚öΩ‚öΩ‚öΩ ¬°DISPARO! Potencia: ${(finalPower * 100).toFixed(0)}%`);
            console.log(`üéØ Apuntado: ${(this.kickTarget.x * 100).toFixed(0)}%`);
            
            // Convertir posici√≥n X (0-1) a posici√≥n en pantalla
            const screenX = this.kickTarget.x;
            
            this.emit('shoot', {
                power: finalPower,
                target: { x: screenX, y: 0.5 }
            });
            
            if (this.movementIndicator) {
                this.movementIndicator.innerHTML = '‚öΩ<br>¬°DISPARO!';
                this.movementIndicator.style.borderColor = '#ff0000';
            }
            
            this.updateStatus('‚öΩüî• ¬°¬°¬°GOOOOOL!!!');
            
            this.resetKickState();
            this.shotCooldown = true;
            
            setTimeout(() => {
                this.shotCooldown = false;
                this.updateStatus('‚úÖ Listo para siguiente tiro');
                if (this.movementIndicator) {
                    this.movementIndicator.innerHTML = 'ü•Ö<br>LISTO';
                    this.movementIndicator.style.borderColor = '#0f0';
                }
            }, this.COOLDOWN_TIME);
        }
        
        // CANCELACI√ìN: Si baja sin extensi√≥n r√°pida
        if (!isKneeFlexed && this.wasKneeFlexed && !isExtending) {
            console.log('‚ö†Ô∏è Baja lenta - Cancelado');
            this.resetKickState();
            this.updateStatus('‚ùå Cancelado - ¬°Extiende r√°pido para disparar!');
        }
    }

    resetKickState() {
        this.isKneeFlexed = false;
        this.wasKneeFlexed = false;
        this.isLegExtended = false;
        this.kickPower = 0;
        this.updatePowerBar(0);
        this.ankleHistory = [];
    }

    updatePowerBar(percentage) {
        if (this.powerFill) {
            this.powerFill.style.height = `${percentage}%`;
        }
        if (this.powerLabel) {
            this.powerLabel.textContent = `${Math.floor(percentage)}%`;
        }
    }

    updateStatus(text) {
        if (this.statusDiv) {
            this.statusDiv.textContent = text;
        }
    }

    enable() {
        this.enabled = true;
        this.resetKickState();
        this.calibrationFrames = 0;
        this.baselineAnkleZ = null;
        this.baselineKneeY = null;
        console.log('ü¶∂‚úÖ Kick control ENABLED');
    }

    disable() {
        this.enabled = false;
        this.resetKickState();
        console.log('ü¶∂‚ùå Kick control DISABLED');
    }

    getKickTarget() {
        return this.kickTarget;
    }

    destroy() {
        if (this.camera) {
            this.camera.stop();
        }
        
        if (this.videoElement && this.videoElement.srcObject) {
            const tracks = this.videoElement.srcObject.getTracks();
            tracks.forEach(track => track.stop());
        }
        
        const container = document.getElementById('kick-camera-container');
        if (container) {
            container.remove();
        }
    }
}
</file>

<file path="src/experience/ShotModel.js">
import * as THREE from 'three';

export default class ShotModel {
    constructor() {
        this.maxPowerSpeed = 50;
        this.liftFactor = 0.25; // Podemos darle un buen efecto de elevaci√≥n
    }

    calculateTrajectory(cameraRotation, power, pressure) {
        // --- L√ìGICA DE F√çSICA COMPLETAMENTE REESCRITA (Y SIMPLIFICADA) ---

        // 1. Definimos la elevaci√≥n del disparo basado en la potencia.
        const liftAmount = power * this.liftFactor;
        
        // 2. Creamos un vector de direcci√≥n base EN ESPACIO DE C√ÅMARA.
        // Ya est√° apuntando hacia adelante (-Z) y hacia arriba (+Y).
        let direction = new THREE.Vector3(0, liftAmount, -1);
        
        // 3. NORMALIZAMOS el vector. ¬°Este paso es CRUCIAL!
        // Asegura que el vector tiene una longitud de 1, para que la velocidad sea consistente.
        direction.normalize();

        // 4. AHORA rotamos este vector perfecto al espacio del mundo, seg√∫n donde mira el jugador.
        direction.applyEuler(cameraRotation);
        
        // 5. A√±adimos la imprecisi√≥n por presi√≥n (esto no cambia)
        const noiseX = (Math.random() - 0.5) * pressure * 0.2;
        const noiseY = (Math.random() - 0.5) * pressure * 0.15;
        direction.x += noiseX;
        direction.y += noiseY;
        
        // 6. Calculamos la velocidad final
        const initialSpeed = this.maxPowerSpeed * power;
        const initialVelocity = direction.clone().multiplyScalar(initialSpeed);

        // El resto es para la IA, no afecta la trayectoria real
        const distanceToGoal = 15;
        const timeToGoal = Math.abs(distanceToGoal / initialVelocity.z);
        const targetPoint = new THREE.Vector3(
            initialVelocity.x * timeToGoal,
            0.1 + initialVelocity.y * timeToGoal - 0.5 * 9.8 * timeToGoal * timeToGoal,
            -distanceToGoal
        );

        return { initialVelocity, targetPoint };
    }
}
</file>

<file path="src/experience/Stadium.js">
import * as THREE from 'three';
import gsap from 'gsap';

export default class Stadium {
    constructor(scene) {
        this.scene = scene;
        this.crowd = [];
        this.flags = [];
        this.lights = [];
        this.createStadium();
    }

    createStadium() {
        console.log('üèüÔ∏è Construyendo estadio...');
        
        // Inicializar todos los materiales compartidos primero
        this.initializeSharedMaterials();
        
        // Crear las gradas
        this.createStands();
        
        // Crear la multitud
        this.createCrowd();
        
        // Crear banderas y decoraci√≥n
        this.createFlags();
        
        // Crear iluminaci√≥n del estadio
        this.createStadiumLights();
        
        // Crear iluminaci√≥n adicional para las gradas
        this.createStandLighting();
        
        // Crear el campo con l√≠neas
        this.createField();
        
        // Crear elementos adicionales
        this.createExtraElements();
        
        console.log('‚úÖ Estadio construido completamente');
    }

    initializeSharedMaterials() {
        console.log('üé® Inicializando materiales compartidos...');
        
        // Materiales b√°sicos para personas
        if (!Stadium.sharedMaterials) {
            Stadium.sharedMaterials = {
                skin: new THREE.MeshLambertMaterial({ color: 0xffdbac }),
                pants: new THREE.MeshLambertMaterial({ color: 0x1a1a1a }),
                hair: new THREE.MeshLambertMaterial({ color: 0x2d1810 }),
                hat: new THREE.MeshLambertMaterial({ color: 0x333333 })
            };
        }
        
        // Materiales de equipos
        if (!Stadium.teamMaterials) {
            Stadium.teamMaterials = {
                argentina: [
                    new THREE.MeshLambertMaterial({ color: 0x87CEEB }), // Celeste cl√°sico
                    new THREE.MeshLambertMaterial({ color: 0x6FB7D3 }), // Celeste claro
                    new THREE.MeshLambertMaterial({ color: 0xFFFFFF }), // Blanco
                ],
                france: [
                    new THREE.MeshLambertMaterial({ color: 0x002395 }), // Azul Francia
                    new THREE.MeshLambertMaterial({ color: 0xFF0000 }), // Rojo Francia
                    new THREE.MeshLambertMaterial({ color: 0xFFFFFF }), // Blanco Francia
                ]
            };
        }
        
        // Materiales de gradas
        if (!Stadium.standMaterials) {
            Stadium.standMaterials = {
                base: new THREE.MeshLambertMaterial({ color: 0x666666 }),
                mainSeat: new THREE.MeshLambertMaterial({ color: 0x1f4e79 }),
                sideSeat: new THREE.MeshLambertMaterial({ color: 0x2d5aa0 }),
                structure: new THREE.MeshLambertMaterial({ color: 0x555555 })
            };
        }
        
        // Otros materiales compartidos
        if (!Stadium.railingMaterial) {
            Stadium.railingMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
        }
        
        if (!Stadium.screenMaterials) {
            Stadium.screenMaterials = {
                support: new THREE.MeshLambertMaterial({ color: 0x333333 }),
                frame: new THREE.MeshLambertMaterial({ color: 0x111111 }),
                screen: new THREE.MeshBasicMaterial({ 
                    color: 0x001122,
                    emissive: 0x002244,
                    emissiveIntensity: 0.3
                })
            };
        }
        
        if (!Stadium.tunnelMaterials) {
            Stadium.tunnelMaterials = {
                tunnel: new THREE.MeshLambertMaterial({ color: 0x444444 }),
                entrance: new THREE.MeshLambertMaterial({ color: 0x222222 }),
                sign: new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
            };
        }
        
        if (!Stadium.adMaterials) {
            Stadium.adMaterials = {
                support: new THREE.MeshLambertMaterial({ color: 0x666666 }),
                boards: [
                    new THREE.MeshBasicMaterial({ color: 0xFF0000 }), // Rojo
                    new THREE.MeshBasicMaterial({ color: 0x0066FF }), // Azul
                    new THREE.MeshBasicMaterial({ color: 0x00AA00 }), // Verde
                    new THREE.MeshBasicMaterial({ color: 0xFF6600 }), // Naranja
                    new THREE.MeshBasicMaterial({ color: 0x9900CC })  // Morado
                ]
            };
        }
        
        if (!Stadium.towerMaterials) {
            Stadium.towerMaterials = {
                base: new THREE.MeshLambertMaterial({ color: 0x444444 }),
                tower: new THREE.MeshLambertMaterial({ color: 0x555555 }),
                platform: new THREE.MeshLambertMaterial({ color: 0x666666 }),
                spot: new THREE.MeshBasicMaterial({ color: 0x888888 }),
                halo: new THREE.MeshBasicMaterial({ 
                    color: 0xffffdd,
                    emissive: 0xffffdd,
                    emissiveIntensity: 0.7
                })
            };
        }
        
        if (!Stadium.confettiMaterials) {
            const confettiGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.02);
            Stadium.confettiMaterials = {
                geometry: confettiGeometry,
                materials: [
                    new THREE.MeshBasicMaterial({ color: 0x87CEEB }),
                    new THREE.MeshBasicMaterial({ color: 0x0055AA }),
                    new THREE.MeshBasicMaterial({ color: 0xFFD700 }),
                    new THREE.MeshBasicMaterial({ color: 0xFF0000 }),
                    new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
                ]
            };
        }
        
        console.log('‚úÖ Materiales compartidos inicializados');
    }

    createStands() {
        console.log('üèóÔ∏è Creando gradas realistas...');
        
        // Crear grader√≠a principal detr√°s del arco (m√°s alta y realista)
        this.createRealisticStand(0, 0, -28, 35, 12, 8, 'main');
        
        // Gradas laterales (m√°s bajas)
        this.createRealisticStand(-25, 0, -5, 8, 8, 40, 'side');
        this.createRealisticStand(25, 0, -5, 8, 8, 40, 'side');
        
        // Grader√≠a detr√°s del jugador (m√°s peque√±a)
        this.createRealisticStand(0, 0, 22, 30, 6, 6, 'back');
        
        console.log('‚úÖ Gradas realistas creadas');
    }

    createRealisticStand(x, y, z, width, height, depth, type) {
        const standGroup = new THREE.Group();
        
        // Reutilizar materiales de gradas
        if (!Stadium.standMaterials) {
            Stadium.standMaterials = {
                base: new THREE.MeshLambertMaterial({ color: 0x666666 }),
                mainSeat: new THREE.MeshLambertMaterial({ color: 0x1f4e79 }),
                sideSeat: new THREE.MeshLambertMaterial({ color: 0x2d5aa0 }),
                structure: new THREE.MeshLambertMaterial({ color: 0x555555 })
            };
        }
        
        // Estructura base de concreto
        const baseGeometry = new THREE.BoxGeometry(width, 1, depth);
        const base = new THREE.Mesh(baseGeometry, Stadium.standMaterials.base);
        base.position.y = 0.5;
        standGroup.add(base);
        
        // Simplificar asientos - menos filas y asientos m√°s grandes
        const rows = Math.floor(height / 2.4); // Menos filas para mejor rendimiento
        const seatWidth = 0.8; // Asientos m√°s grandes
        const seatDepth = 0.8;
        const seatHeight = 0.6;
        const rowSpacing = 2.4;
        
        const seatMaterial = type === 'main' ? Stadium.standMaterials.mainSeat : Stadium.standMaterials.sideSeat;
        
        for (let row = 0; row < rows; row++) {
            const rowY = 1 + row * rowSpacing;
            const rowZ = (row * 1.6) - (depth / 2) + 1;
            
            // Menos asientos por fila para mejor rendimiento
            const seatsInRow = Math.floor(width / (seatWidth + 0.2));
            
            // Crear una fila como un bloque para mejor rendimiento
            const rowSeatsGeometry = new THREE.BoxGeometry(width * 0.9, seatHeight * 0.4, seatDepth);
            const rowSeats = new THREE.Mesh(rowSeatsGeometry, seatMaterial);
            rowSeats.position.set(0, rowY, rowZ);
            standGroup.add(rowSeats);
            
            // Respaldos como un bloque
            const rowBackrestGeometry = new THREE.BoxGeometry(width * 0.9, seatHeight * 0.6, 0.1);
            const rowBackrest = new THREE.Mesh(rowBackrestGeometry, seatMaterial);
            rowBackrest.position.set(0, rowY + seatHeight * 0.2, rowZ - seatDepth/2);
            standGroup.add(rowBackrest);
            
            // Estructura de la fila simplificada
            const rowStructure = new THREE.BoxGeometry(width, 0.3, 1.5);
            const rowMesh = new THREE.Mesh(rowStructure, Stadium.standMaterials.structure);
            rowMesh.position.set(0, rowY - 0.4, rowZ);
            standGroup.add(rowMesh);
        }
        
        // Barandas simplificadas
        this.addSimplifiedRailings(standGroup, width, height, depth, rows);
        
        standGroup.position.set(x, y, z);
        this.scene.add(standGroup);
    }

    addSimplifiedRailings(standGroup, width, height, depth, rows) {
        if (!Stadium.railingMaterial) {
            Stadium.railingMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
        }
        
        // Barandas frontales simplificadas - solo una por grader√≠a
        const railingGeometry = new THREE.BoxGeometry(width, 0.1, 0.1);
        const railing = new THREE.Mesh(railingGeometry, Stadium.railingMaterial);
        railing.position.set(0, height * 0.7, -depth/2 + 1);
        standGroup.add(railing);
        
        // Solo 2 postes principales para mejor rendimiento
        const postPositions = [-width/4, width/4];
        postPositions.forEach(postX => {
            const postGeometry = new THREE.BoxGeometry(0.1, height * 0.8, 0.1);
            const post = new THREE.Mesh(postGeometry, Stadium.railingMaterial);
            post.position.set(postX, height/2 + 1, -depth/2);
            standGroup.add(post);
        });
    }

    createCrowd() {
        console.log('üë• Creando multitud realista...');
        
        // Crear personas m√°s realistas en las gradas existentes
        this.createRealisticCrowdInStand(0, 1, -28, 35, 12, 8, 'main');
        this.createRealisticCrowdInStand(-25, 1, -5, 8, 8, 40, 'side');
        this.createRealisticCrowdInStand(25, 1, -5, 8, 8, 40, 'side');
        this.createRealisticCrowdInStand(0, 1, 22, 30, 6, 6, 'back');
        
        console.log(`‚úÖ ${this.crowd.length} personas realistas creadas en las gradas`);
        
        // Animaci√≥n de la multitud
        this.animateCrowd();
    }

    createRealisticCrowdInStand(x, y, z, width, height, depth, standType) {
        const crowdGroup = new THREE.Group();
        
        // Asegurar que todos los materiales est√©n inicializados
        this.initializeSharedMaterials();
        
        const argentinaMaterials = Stadium.teamMaterials.argentina;
        const franceMaterials = Stadium.teamMaterials.france;
        
        // Reducir densidad de multitud para mejor rendimiento
        const rows = Math.floor(height / 2.4); // Menos filas
        const rowSpacing = 2.4;
        
        for (let row = 0; row < rows; row++) {
            const rowY = y + row * rowSpacing;
            const rowZ = z + (row * 1.6) - (depth / 2) + 1;
            
            const peopleInRow = Math.floor(width / 1.0); // Menos personas por fila
            
            for (let person = 0; person < peopleInRow; person++) {
                if (Math.random() < 0.6) { // 60% ocupaci√≥n para mejor rendimiento
                    const personX = x + (person - peopleInRow/2) * 1.0 + (Math.random() - 0.5) * 0.4;
                    
                    // Crear persona simplificada para mejor rendimiento
                    const personGroup = this.createSimplifiedPerson();
                    
                    // Asignar equipo seg√∫n la posici√≥n
                    const isArgentinaSide = standType === 'main' ? personX < 0 : Math.random() < 0.5;
                    const materials = isArgentinaSide ? argentinaMaterials : franceMaterials;
                    const chosenMaterial = materials[Math.floor(Math.random() * materials.length)];
                    
                    // Aplicar material a la camiseta
                    if (personGroup.children[0]) { // Cuerpo principal
                        personGroup.children[0].material = chosenMaterial;
                    }
                    
                    personGroup.position.set(
                        personX,
                        rowY + 0.6,
                        rowZ + (Math.random() - 0.5) * 0.6
                    );
                    
                    // Rotaci√≥n aleatoria para m√°s naturalidad
                    personGroup.rotation.y = (Math.random() - 0.5) * 0.8;
                    
                    crowdGroup.add(personGroup);
                    this.crowd.push(personGroup);
                }
            }
        }
        
        this.scene.add(crowdGroup);
    }

    createRealisticPerson() {
        const personGroup = new THREE.Group();
        
        // Los materiales ya est√°n inicializados en initializeSharedMaterials()
        const skinMaterial = Stadium.sharedMaterials.skin;
        const pantsMaterial = Stadium.sharedMaterials.pants;
        const hairMaterial = Stadium.sharedMaterials.hair;
        
        // Cabeza
        const headGeometry = new THREE.SphereGeometry(0.12, 8, 6);
        const head = new THREE.Mesh(headGeometry, skinMaterial);
        head.position.y = 0.75;
        personGroup.add(head);
        
        // Torso (camiseta del equipo - se asignar√° despu√©s)
        const torsoGeometry = new THREE.CylinderGeometry(0.15, 0.18, 0.4, 8);
        const torso = new THREE.Mesh(torsoGeometry, new THREE.MeshLambertMaterial({ color: 0x87CEEB }));
        torso.position.y = 0.4;
        personGroup.add(torso);
        
        // Brazos
        const armGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.3, 6);
        
        const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
        leftArm.position.set(-0.2, 0.45, 0);
        leftArm.rotation.z = Math.PI / 6 + (Math.random() - 0.5) * 0.5;
        personGroup.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
        rightArm.position.set(0.2, 0.45, 0);
        rightArm.rotation.z = -Math.PI / 6 + (Math.random() - 0.5) * 0.5;
        personGroup.add(rightArm);
        
        // Piernas
        const legGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 6);
        
        const leftLeg = new THREE.Mesh(legGeometry, pantsMaterial);
        leftLeg.position.set(-0.08, 0.05, 0);
        personGroup.add(leftLeg);
        
        const rightLeg = new THREE.Mesh(legGeometry, pantsMaterial);
        rightLeg.position.set(0.08, 0.05, 0);
        personGroup.add(rightLeg);
        
        // Pelo (aleatorio)
        if (Math.random() < 0.8) {
            const hairGeometry = new THREE.SphereGeometry(0.13, 8, 6);
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 0.78;
            hair.scale.y = 0.6;
            personGroup.add(hair);
        }
        
        // Accesorios aleatorios (sombreros, banderas peque√±as, etc.)
        if (Math.random() < 0.3) {
            const hatGeometry = new THREE.CylinderGeometry(0.14, 0.14, 0.05, 8);
            const hat = new THREE.Mesh(hatGeometry, Stadium.sharedMaterials.hat);
            hat.position.y = 0.85;
            personGroup.add(hat);
        }
        
        return personGroup;
    }

    createSimplifiedPerson() {
        const personGroup = new THREE.Group();
        
        // Los materiales ya est√°n inicializados en initializeSharedMaterials()
        // Persona muy simplificada para mejor rendimiento
        // Solo un cilindro para el cuerpo y una esfera para la cabeza
        
        // Cuerpo (camiseta del equipo - se asignar√° despu√©s)
        const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.18, 0.8, 6); // Menos segmentos
        const body = new THREE.Mesh(bodyGeometry, Stadium.sharedMaterials.skin);
        body.position.y = 0.4;
        personGroup.add(body);
        
        // Cabeza simplificada
        const headGeometry = new THREE.SphereGeometry(0.12, 6, 4); // Menos segmentos
        const head = new THREE.Mesh(headGeometry, Stadium.sharedMaterials.skin);
        head.position.y = 0.9;
        personGroup.add(head);
        
        return personGroup;
    }

    createCrowdSection(centerX, centerY, centerZ, width, depth, materials) {
        const crowdGroup = new THREE.Group();
        const personGeometry = new THREE.CapsuleGeometry(0.3, 1.2, 4, 8);
        
        // Densidad de personas
        const spacing = 1.2;
        const rowsX = Math.floor(width / spacing);
        const rowsZ = Math.floor(depth / spacing);
        
        for (let x = 0; x < rowsX; x++) {
            for (let z = 0; z < rowsZ; z++) {
                // A√±adir algo de aleatoriedad para que no se vea tan perfecto
                if (Math.random() < 0.85) { // 85% probabilidad de que haya una persona
                    const material = materials[Math.floor(Math.random() * materials.length)];
                    const person = new THREE.Mesh(personGeometry, material);
                    
                    person.position.set(
                        centerX + (x - rowsX/2) * spacing + (Math.random() - 0.5) * 0.3,
                        centerY + Math.random() * 0.5,
                        centerZ + (z - rowsZ/2) * spacing + (Math.random() - 0.5) * 0.3
                    );
                    
                    // Rotaci√≥n aleatoria para m√°s realismo
                    person.rotation.y = (Math.random() - 0.5) * 0.5;
                    
                    crowdGroup.add(person);
                    this.crowd.push(person);
                }
            }
        }
        
        this.scene.add(crowdGroup);
    }

    animateCrowd() {
        console.log('üéä Animando multitud...');
        
        this.crowd.forEach((person, index) => {
            // Animaci√≥n de salto aleatorio
            gsap.to(person.position, {
                y: person.position.y + 0.2 + Math.random() * 0.3,
                duration: 0.5 + Math.random() * 0.5,
                ease: 'power2.out',
                yoyo: true,
                repeat: -1,
                delay: Math.random() * 2,
                repeatDelay: 1 + Math.random() * 3
            });
            
            // Movimiento lateral sutil
            gsap.to(person.position, {
                x: person.position.x + (Math.random() - 0.5) * 0.2,
                duration: 2 + Math.random() * 2,
                ease: 'sine.inOut',
                yoyo: true,
                repeat: -1,
                delay: Math.random() * 4
            });
        });
    }

    createFlags() {
        console.log('üè≥Ô∏è Creando banderas de Argentina y Francia...');
        
        // Banderas argentinas (lado izquierdo)
        this.createArgentinaFlag(-15, 15, -25);
        this.createArgentinaFlag(-8, 13, -25);
        this.createArgentinaFlag(-22, 10, -10);
        this.createArgentinaFlag(-12, 8, 20);
        
        // Banderas francesas (lado derecho)
        this.createFranceFlag(15, 15, -25);
        this.createFranceFlag(8, 13, -25);
        this.createFranceFlag(22, 10, -10);
        this.createFranceFlag(12, 8, 20);
        
        // Banderas gigantes en la grader√≠a principal
        this.createGiantArgentinaFlag(-20, 18, -30);
        this.createGiantFranceFlag(20, 18, -30);
        
        console.log('‚úÖ Banderas de Argentina y Francia creadas');
    }

    createArgentinaFlag(x, y, z) {
        const flagGroup = new THREE.Group();
        
        // M√°stil
        const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4);
        const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
        pole.position.y = 2;
        flagGroup.add(pole);
        
        // Bandera argentina (3 franjas)
        const flagWidth = 2.5;
        const flagHeight = 1.5;
        
        // Franja celeste superior
        const topStripe = new THREE.PlaneGeometry(flagWidth, flagHeight / 3);
        const celesteMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB, side: THREE.DoubleSide });
        const topFlag = new THREE.Mesh(topStripe, celesteMaterial);
        topFlag.position.set(flagWidth/2, 3.5, 0);
        flagGroup.add(topFlag);
        
        // Franja blanca central
        const middleStripe = new THREE.PlaneGeometry(flagWidth, flagHeight / 3);
        const whiteMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide });
        const middleFlag = new THREE.Mesh(middleStripe, whiteMaterial);
        middleFlag.position.set(flagWidth/2, 3.2, 0);
        flagGroup.add(middleFlag);
        
        // Sol de Mayo (c√≠rculo amarillo en el centro)
        const sunGeometry = new THREE.CircleGeometry(0.15, 16);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700, side: THREE.DoubleSide });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(flagWidth/2, 3.2, 0.01);
        flagGroup.add(sun);
        
        // Franja celeste inferior
        const bottomStripe = new THREE.PlaneGeometry(flagWidth, flagHeight / 3);
        const bottomFlag = new THREE.Mesh(bottomStripe, celesteMaterial);
        bottomFlag.position.set(flagWidth/2, 2.9, 0);
        flagGroup.add(bottomFlag);
        
        flagGroup.position.set(x, y, z);
        this.scene.add(flagGroup);
        this.flags.push(flagGroup);
        
        // Animaci√≥n de ondeo
        [topFlag, middleFlag, bottomFlag].forEach((flag, index) => {
            gsap.to(flag.rotation, {
                z: 0.1 + Math.random() * 0.05,
                duration: 1.5 + Math.random() * 0.5,
                ease: 'sine.inOut',
                yoyo: true,
                repeat: -1,
                delay: index * 0.1
            });
        });
    }

    createFranceFlag(x, y, z) {
        const flagGroup = new THREE.Group();
        
        // M√°stil
        const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4);
        const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
        pole.position.y = 2;
        flagGroup.add(pole);
        
        // Bandera francesa (3 franjas verticales)
        const flagWidth = 2.5;
        const flagHeight = 1.5;
        const stripeWidth = flagWidth / 3;
        
        // Franja azul
        const blueStripe = new THREE.PlaneGeometry(stripeWidth, flagHeight);
        const blueMaterial = new THREE.MeshLambertMaterial({ color: 0x002395, side: THREE.DoubleSide });
        const blueFlag = new THREE.Mesh(blueStripe, blueMaterial);
        blueFlag.position.set(stripeWidth/2, 3.2, 0);
        flagGroup.add(blueFlag);
        
        // Franja blanca
        const whiteStripe = new THREE.PlaneGeometry(stripeWidth, flagHeight);
        const whiteMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide });
        const whiteFlag = new THREE.Mesh(whiteStripe, whiteMaterial);
        whiteFlag.position.set(stripeWidth * 1.5, 3.2, 0);
        flagGroup.add(whiteFlag);
        
        // Franja roja
        const redStripe = new THREE.PlaneGeometry(stripeWidth, flagHeight);
        const redMaterial = new THREE.MeshLambertMaterial({ color: 0xED2939, side: THREE.DoubleSide });
        const redFlag = new THREE.Mesh(redStripe, redMaterial);
        redFlag.position.set(stripeWidth * 2.5, 3.2, 0);
        flagGroup.add(redFlag);
        
        flagGroup.position.set(x, y, z);
        this.scene.add(flagGroup);
        this.flags.push(flagGroup);
        
        // Animaci√≥n de ondeo
        [blueFlag, whiteFlag, redFlag].forEach((flag, index) => {
            gsap.to(flag.rotation, {
                z: 0.1 + Math.random() * 0.05,
                duration: 1.3 + Math.random() * 0.4,
                ease: 'sine.inOut',
                yoyo: true,
                repeat: -1,
                delay: index * 0.1
            });
        });
    }

    createGiantArgentinaFlag(x, y, z) {
        const flagGroup = new THREE.Group();
        
        // Usar colores simples sin texturas para reducir uso de GPU
        const flagWidth = 8;
        const flagHeight = 4;
        
        // Franja celeste superior
        const topGeometry = new THREE.PlaneGeometry(flagWidth, flagHeight / 3);
        const celesteMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB, side: THREE.DoubleSide });
        const topFlag = new THREE.Mesh(topGeometry, celesteMaterial);
        topFlag.position.y = flagHeight / 3;
        flagGroup.add(topFlag);
        
        // Franja blanca central
        const middleGeometry = new THREE.PlaneGeometry(flagWidth, flagHeight / 3);
        const whiteMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide });
        const middleFlag = new THREE.Mesh(middleGeometry, whiteMaterial);
        middleFlag.position.y = 0;
        flagGroup.add(middleFlag);
        
        // Sol simple
        const sunGeometry = new THREE.CircleGeometry(0.3, 16);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700, side: THREE.DoubleSide });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(0, 0, 0.01);
        flagGroup.add(sun);
        
        // Franja celeste inferior
        const bottomGeometry = new THREE.PlaneGeometry(flagWidth, flagHeight / 3);
        const bottomFlag = new THREE.Mesh(bottomGeometry, celesteMaterial);
        bottomFlag.position.y = -flagHeight / 3;
        flagGroup.add(bottomFlag);
        
        flagGroup.position.set(x, y, z);
        this.scene.add(flagGroup);
        this.flags.push(flagGroup);
        
        // Animaci√≥n simple
        gsap.to(flagGroup.rotation, {
            z: 0.05,
            duration: 2,
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
    }

    createGiantFranceFlag(x, y, z) {
        const flagGroup = new THREE.Group();
        
        // Usar colores simples sin texturas
        const flagWidth = 8;
        const flagHeight = 4;
        
        // Franja azul
        const blueGeometry = new THREE.PlaneGeometry(flagWidth / 3, flagHeight);
        const blueMaterial = new THREE.MeshLambertMaterial({ color: 0x002395, side: THREE.DoubleSide });
        const blueFlag = new THREE.Mesh(blueGeometry, blueMaterial);
        blueFlag.position.x = -flagWidth / 3;
        flagGroup.add(blueFlag);
        
        // Franja blanca
        const whiteGeometry = new THREE.PlaneGeometry(flagWidth / 3, flagHeight);
        const whiteMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide });
        const whiteFlag = new THREE.Mesh(whiteGeometry, whiteMaterial);
        whiteFlag.position.x = 0;
        flagGroup.add(whiteFlag);
        
        // Franja roja
        const redGeometry = new THREE.PlaneGeometry(flagWidth / 3, flagHeight);
        const redMaterial = new THREE.MeshLambertMaterial({ color: 0xED2939, side: THREE.DoubleSide });
        const redFlag = new THREE.Mesh(redGeometry, redMaterial);
        redFlag.position.x = flagWidth / 3;
        flagGroup.add(redFlag);
        
        flagGroup.position.set(x, y, z);
        this.scene.add(flagGroup);
        this.flags.push(flagGroup);
        
        // Animaci√≥n simple
        gsap.to(flagGroup.rotation, {
            z: 0.05,
            duration: 2.2,
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
    }

    createFlag(x, y, z, color1, color2) {
        const flagGroup = new THREE.Group();
        
        // M√°stil
        const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3);
        const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
        pole.position.y = 1.5;
        flagGroup.add(pole);
        
        // Bandera (dos colores)
        const flagGeometry = new THREE.PlaneGeometry(2, 1);
        const flagMaterial1 = new THREE.MeshLambertMaterial({ color: color1, side: THREE.DoubleSide });
        const flagMaterial2 = new THREE.MeshLambertMaterial({ color: color2, side: THREE.DoubleSide });
        
        const flag1 = new THREE.Mesh(flagGeometry, flagMaterial1);
        flag1.position.set(1, 2.5, 0);
        flag1.scale.y = 0.5;
        flagGroup.add(flag1);
        
        const flag2 = new THREE.Mesh(flagGeometry, flagMaterial2);
        flag2.position.set(1, 2, 0);
        flag2.scale.y = 0.5;
        flagGroup.add(flag2);
        
        flagGroup.position.set(x, y, z);
        this.scene.add(flagGroup);
        this.flags.push(flagGroup);
        
        // Animaci√≥n de ondeo
        gsap.to(flag1.rotation, {
            z: 0.1,
            duration: 1 + Math.random(),
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
        
        gsap.to(flag2.rotation, {
            z: 0.15,
            duration: 1.2 + Math.random(),
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
    }

    createStadiumLights() {
        console.log('üí° Creando iluminaci√≥n profesional del estadio...');
        
        // Torres de iluminaci√≥n m√°s realistas y altas
        const towerPositions = [
            [-30, 25, -15],
            [30, 25, -15],
            [-30, 25, 5],
            [30, 25, 5]
        ];
        
        towerPositions.forEach((pos, index) => {
            this.createLightTower(pos[0], pos[1], pos[2], index);
        });
        
        // Iluminaci√≥n perimetral adicional
        this.createPerimeterLighting();
        
        console.log('‚úÖ Iluminaci√≥n profesional del estadio creada');
    }

    createStandLighting() {
        console.log('üí° Creando iluminaci√≥n espec√≠fica para las gradas...');
        
        // Luces para iluminar las gradas principales
        const standLightPositions = [
            // Grader√≠a principal detr√°s del arco
            { pos: [-12, 15, -30], target: [-10, 6, -25], intensity: 0.7 },
            { pos: [0, 18, -35], target: [0, 8, -25], intensity: 0.8 },
            { pos: [12, 15, -30], target: [10, 6, -25], intensity: 0.7 },
            
            // Gradas laterales
            { pos: [-30, 12, -10], target: [-25, 6, -5], intensity: 0.6 },
            { pos: [-30, 12, 5], target: [-25, 6, 0], intensity: 0.6 },
            { pos: [30, 12, -10], target: [25, 6, -5], intensity: 0.6 },
            { pos: [30, 12, 5], target: [25, 6, 0], intensity: 0.6 },
            
            // Grader√≠a detr√°s del jugador
            { pos: [-8, 10, 25], target: [-5, 4, 20], intensity: 0.5 },
            { pos: [8, 10, 25], target: [5, 4, 20], intensity: 0.5 }
        ];
        
        standLightPositions.forEach(lightConfig => {
            // Luz direccional para iluminar las gradas
            const standLight = new THREE.DirectionalLight(0xffffee, lightConfig.intensity);
            standLight.position.set(lightConfig.pos[0], lightConfig.pos[1], lightConfig.pos[2]);
            standLight.target.position.set(lightConfig.target[0], lightConfig.target[1], lightConfig.target[2]);
            standLight.castShadow = false;
            
            this.scene.add(standLight);
            this.scene.add(standLight.target);
            this.lights.push(standLight);
        });
        
        // Luces ambiente adicionales para mejor visibilidad general
        const ambientPositions = [
            [0, 25, -20], [0, 25, 0], [0, 25, 15],
            [-20, 20, -10], [20, 20, -10]
        ];
        
        ambientPositions.forEach(pos => {
            const ambientLight = new THREE.PointLight(0xffffff, 0.4, 50);
            ambientLight.position.set(pos[0], pos[1], pos[2]);
            this.scene.add(ambientLight);
            this.lights.push(ambientLight);
        });
        
        console.log('‚úÖ Iluminaci√≥n de gradas creada');
    }

    createLightTower(x, y, z, index) {
        const towerGroup = new THREE.Group();
        
        // Reutilizar materiales de torres
        if (!Stadium.towerMaterials) {
            Stadium.towerMaterials = {
                base: new THREE.MeshLambertMaterial({ color: 0x444444 }),
                tower: new THREE.MeshLambertMaterial({ color: 0x555555 }),
                platform: new THREE.MeshLambertMaterial({ color: 0x666666 }),
                spot: new THREE.MeshBasicMaterial({ color: 0x888888 }),
                halo: new THREE.MeshBasicMaterial({ 
                    color: 0xffffdd,
                    emissive: 0xffffdd,
                    emissiveIntensity: 0.7
                })
            };
        }
        
        // Base de la torre (simplificada)
        const baseGeometry = new THREE.BoxGeometry(3, 3, 3); // Box en lugar de cilindro
        const base = new THREE.Mesh(baseGeometry, Stadium.towerMaterials.base);
        base.position.y = 1.5;
        towerGroup.add(base);
        
        // Torre principal (simplificada)
        const towerGeometry = new THREE.BoxGeometry(0.8, 20, 0.8); // Box en lugar de cilindro
        const tower = new THREE.Mesh(towerGeometry, Stadium.towerMaterials.tower);
        tower.position.y = 13;
        towerGroup.add(tower);
        
        // Plataforma de luces (simplificada)
        const platformGeometry = new THREE.BoxGeometry(4, 1, 4); // Box en lugar de cilindro
        const platform = new THREE.Mesh(platformGeometry, Stadium.towerMaterials.platform);
        platform.position.y = 23.5;
        towerGroup.add(platform);
        
        // Solo 3 focos principales para mejor rendimiento
        const lightPositions = [
            [0, 0], [1.5, 0], [-1.5, 0]
        ];
        
        lightPositions.forEach((lightPos, lightIndex) => {
            // Foco visual simplificado
            const spotGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.6); // Box en lugar de cilindro
            const spotMesh = new THREE.Mesh(spotGeometry, Stadium.towerMaterials.spot);
            spotMesh.position.set(lightPos[0], 24, lightPos[1]);
            towerGroup.add(spotMesh);
            
            // Luz real m√°s intensa para mejor iluminaci√≥n
            const spotlight = new THREE.SpotLight(0xffffee, 0.8, 60, Math.PI/4, 0.3);
            spotlight.position.set(x + lightPos[0], y, z + lightPos[1]);
            spotlight.target.position.set(0, 0, -7);
            spotlight.castShadow = false; // Desactivar sombras para mejor rendimiento
            
            this.scene.add(spotlight);
            this.scene.add(spotlight.target);
            this.lights.push(spotlight);
            
            // Halo de luz simplificado
            const haloGeometry = new THREE.SphereGeometry(0.2, 8, 6); // Menos segmentos
            const halo = new THREE.Mesh(haloGeometry, Stadium.towerMaterials.halo);
            halo.position.set(lightPos[0], 24, lightPos[1]);
            towerGroup.add(halo);
        });
        
        towerGroup.position.set(x, 0, z);
        this.scene.add(towerGroup);
    }

    createPerimeterLighting() {
        // Luces perimetrales m√°s intensas alrededor del campo
        const perimeterPositions = [
            [-15, 12, -25], [0, 12, -25], [15, 12, -25], // Detr√°s del arco
            [-25, 10, 0], [25, 10, 0], // Laterales
            [-10, 8, 20], [10, 8, 20] // Detr√°s del jugador
        ];
        
        perimeterPositions.forEach(pos => {
            // Poste de luz m√°s alto
            const poleGeometry = new THREE.CylinderGeometry(0.15, 0.18, 12);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(pos[0], pos[1]/2, pos[2]);
            this.scene.add(pole);
            
            // Luz punto m√°s intensa
            const light = new THREE.PointLight(0xffffee, 0.8, 40);
            light.position.set(pos[0], pos[1], pos[2]);
            this.scene.add(light);
            this.lights.push(light);
            
            // Luminaria m√°s brillante
            const lampGeometry = new THREE.SphereGeometry(0.3);
            const lampMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffdd,
                emissive: 0xffffdd,
                emissiveIntensity: 0.8
            });
            const lamp = new THREE.Mesh(lampGeometry, lampMaterial);
            lamp.position.set(pos[0], pos[1], pos[2]);
            this.scene.add(lamp);
            
            // A√±adir reflector adicional apuntando al campo
            const spotlight = new THREE.SpotLight(0xffffff, 0.6, 35, Math.PI/3, 0.5);
            spotlight.position.set(pos[0], pos[1], pos[2]);
            spotlight.target.position.set(0, 0, -7);
            this.scene.add(spotlight);
            this.scene.add(spotlight.target);
            this.lights.push(spotlight);
        });
    }

    createField() {
        console.log('‚öΩ Creando campo de juego profesional...');
        
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const lineWidth = 0.12;
        
        // L√≠neas laterales del campo completo
        this.createFieldLine(-34, 0, 0, lineWidth, 68, 'vertical'); // Izquierda
        this.createFieldLine(34, 0, 0, lineWidth, 68, 'vertical');  // Derecha
        this.createFieldLine(0, 0, -34, 68, lineWidth, 'horizontal'); // Fondo
        this.createFieldLine(0, 0, 34, 68, lineWidth, 'horizontal');  // Frente
        
        // L√≠nea central
        this.createFieldLine(0, 0, 0, lineWidth, 68, 'vertical');
        
        // C√≠rculo central
        const circleGeometry = new THREE.RingGeometry(9.15, 9.15 + lineWidth, 64);
        const circle = new THREE.Mesh(circleGeometry, lineMaterial);
        circle.rotation.x = -Math.PI / 2;
        circle.position.y = 0.01;
        this.scene.add(circle);
        
        // Punto central
        const centerSpotGeometry = new THREE.CircleGeometry(0.2, 16);
        const centerSpot = new THREE.Mesh(centerSpotGeometry, lineMaterial);
        centerSpot.rotation.x = -Math.PI / 2;
        centerSpot.position.y = 0.01;
        this.scene.add(centerSpot);
        
        // √Årea grande (√°rea de 18 yardas)
        this.createPenaltyArea(-18, 0, -34, 40.3, 16.5, lineMaterial);
        
        // √Årea peque√±a (√°rea de 6 yardas)
        this.createGoalArea(-5.5, 0, -34, 18.3, 5.5, lineMaterial);
        
        // Arco penal
        const penaltyArcGeometry = new THREE.RingGeometry(9.15, 9.15 + lineWidth, 32, 1, 0, Math.PI);
        const penaltyArc = new THREE.Mesh(penaltyArcGeometry, lineMaterial);
        penaltyArc.rotation.x = -Math.PI / 2;
        penaltyArc.position.set(0, 0.01, -23);
        this.scene.add(penaltyArc);
        
        // Punto de penal (ya existe en SceneManager, pero lo mejoramos)
        const penaltySpotGeometry = new THREE.CircleGeometry(0.2, 16);
        const penaltySpot = new THREE.Mesh(penaltySpotGeometry, lineMaterial);
        penaltySpot.rotation.x = -Math.PI / 2;
        penaltySpot.position.set(0, 0.01, -11);
        this.scene.add(penaltySpot);
        
        // Esquinas (cuartos de c√≠rculo en las esquinas)
        this.createCornerArcs(lineMaterial);
        
        // Patr√≥n de c√©sped m√°s realista
        this.createGrassPattern();
        
        console.log('‚úÖ Campo profesional creado');
    }

    createFieldLine(x, y, z, width, length, orientation) {
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        let geometry;
        if (orientation === 'horizontal') {
            geometry = new THREE.PlaneGeometry(length, width);
        } else {
            geometry = new THREE.PlaneGeometry(width, length);
        }
        
        const line = new THREE.Mesh(geometry, lineMaterial);
        line.rotation.x = -Math.PI / 2;
        line.position.set(x, y + 0.01, z);
        this.scene.add(line);
    }

    createPenaltyArea(x, y, z, width, depth, material) {
        // L√≠nea superior del √°rea
        this.createFieldLine(x, y, z, width, 0.12, 'horizontal');
        
        // L√≠neas laterales del √°rea
        this.createFieldLine(x - width/2, y, z + depth/2, 0.12, depth, 'vertical');
        this.createFieldLine(x + width/2, y, z + depth/2, 0.12, depth, 'vertical');
    }

    createGoalArea(x, y, z, width, depth, material) {
        // L√≠nea superior del √°rea peque√±a
        this.createFieldLine(x, y, z, width, 0.12, 'horizontal');
        
        // L√≠neas laterales del √°rea peque√±a
        this.createFieldLine(x - width/2, y, z + depth/2, 0.12, depth, 'vertical');
        this.createFieldLine(x + width/2, y, z + depth/2, 0.12, depth, 'vertical');
    }

    createCornerArcs(material) {
        const cornerPositions = [
            [-34, 34],   // Esquina superior izquierda
            [34, 34],    // Esquina superior derecha
            [-34, -34],  // Esquina inferior izquierda
            [34, -34]    // Esquina inferior derecha
        ];
        
        cornerPositions.forEach(pos => {
            const arcGeometry = new THREE.RingGeometry(0.9, 1.02, 16, 1, 0, Math.PI/2);
            const arc = new THREE.Mesh(arcGeometry, material);
            arc.rotation.x = -Math.PI / 2;
            arc.position.set(pos[0], 0.01, pos[1]);
            
            // Ajustar rotaci√≥n seg√∫n la esquina
            if (pos[0] > 0 && pos[1] > 0) arc.rotation.z = -Math.PI/2; // Superior derecha
            else if (pos[0] < 0 && pos[1] > 0) arc.rotation.z = 0;     // Superior izquierda
            else if (pos[0] < 0 && pos[1] < 0) arc.rotation.z = Math.PI/2; // Inferior izquierda
            else arc.rotation.z = Math.PI; // Inferior derecha
            
            this.scene.add(arc);
        });
    }

    createGrassPattern() {
        // Crear patr√≥n de c√©sped con franjas m√°s oscuras y claras
        const grassGroup = new THREE.Group();
        
        for (let i = -35; i < 35; i += 4) {
            const stripeGeometry = new THREE.PlaneGeometry(4, 70);
            const isEven = Math.floor((i + 35) / 4) % 2 === 0;
            const grassColor = isEven ? 0x2d6a2b : 0x256322;
            
            const stripeMaterial = new THREE.MeshLambertMaterial({ 
                color: grassColor,
                transparent: true,
                opacity: 0.7
            });
            
            const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            stripe.rotation.x = -Math.PI / 2;
            stripe.position.set(i + 2, 0.005, 0); // Ligeramente por encima del suelo base
            grassGroup.add(stripe);
        }
        
        this.scene.add(grassGroup);
    }

    createExtraElements() {
        console.log('üé™ Creando elementos adicionales del estadio...');
        
        // Pantallas gigantes m√°s realistas
        this.createLEDScreen(-18, 18, -32, 'ARGENTINA vs FRANCIA');
        this.createLEDScreen(18, 18, -32, 'FINAL MUNDIAL 2022');
        
        // T√∫nel de jugadores m√°s elaborado
        this.createPlayerTunnel();
        
        // Bancos de suplentes profesionales
        this.createProfessionalBenches();
        
        // √Årea t√©cnica
        this.createTechnicalArea();
        
        // Publicidad perimetral
        this.createPerimeterAdvertising();
        
        // C√°maras de TV
        this.createTVCameras();
        
        console.log('‚úÖ Elementos adicionales del estadio creados');
    }

    createLEDScreen(x, y, z, text) {
        const screenGroup = new THREE.Group();
        
        // Reutilizar materiales b√°sicos
        if (!Stadium.screenMaterials) {
            Stadium.screenMaterials = {
                support: new THREE.MeshLambertMaterial({ color: 0x333333 }),
                frame: new THREE.MeshLambertMaterial({ color: 0x111111 }),
                screen: new THREE.MeshBasicMaterial({ 
                    color: 0x001122,
                    emissive: 0x002244,
                    emissiveIntensity: 0.3
                })
            };
        }
        
        // Estructura de soporte
        const supportGeometry = new THREE.BoxGeometry(0.5, 8, 0.5);
        
        const leftSupport = new THREE.Mesh(supportGeometry, Stadium.screenMaterials.support);
        leftSupport.position.set(-5, 4, 0);
        screenGroup.add(leftSupport);
        
        const rightSupport = new THREE.Mesh(supportGeometry, Stadium.screenMaterials.support);
        rightSupport.position.set(5, 4, 0);
        screenGroup.add(rightSupport);
        
        // Marco de la pantalla
        const frameGeometry = new THREE.BoxGeometry(12, 6, 0.3);
        const frame = new THREE.Mesh(frameGeometry, Stadium.screenMaterials.frame);
        frame.position.y = 4;
        screenGroup.add(frame);
        
        // Pantalla LED simple sin textura
        const screenGeometry = new THREE.PlaneGeometry(11, 5);
        const screen = new THREE.Mesh(screenGeometry, Stadium.screenMaterials.screen);
        screen.position.set(0, 4, 0.16);
        screenGroup.add(screen);
        
        screenGroup.position.set(x, y, z);
        this.scene.add(screenGroup);
        
        // Animaci√≥n de parpadeo optimizada
        gsap.to(Stadium.screenMaterials.screen, {
            emissiveIntensity: 0.5,
            duration: 3,
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
    }

    createPlayerTunnel() {
        const tunnelGroup = new THREE.Group();
        
        // Reutilizar materiales b√°sicos
        if (!Stadium.tunnelMaterials) {
            Stadium.tunnelMaterials = {
                tunnel: new THREE.MeshLambertMaterial({ color: 0x444444 }),
                entrance: new THREE.MeshLambertMaterial({ color: 0x222222 }),
                sign: new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
            };
        }
        
        // Estructura del t√∫nel
        const tunnelGeometry = new THREE.BoxGeometry(6, 4, 12);
        const tunnel = new THREE.Mesh(tunnelGeometry, Stadium.tunnelMaterials.tunnel);
        tunnel.position.set(0, 2, 28);
        tunnelGroup.add(tunnel);
        
        // Entrada del t√∫nel
        const entranceGeometry = new THREE.BoxGeometry(4, 3, 0.2);
        const entrance = new THREE.Mesh(entranceGeometry, Stadium.tunnelMaterials.entrance);
        entrance.position.set(0, 1.5, 22);
        tunnelGroup.add(entrance);
        
        // Letrero simple sin textura
        const signGeometry = new THREE.PlaneGeometry(3, 0.5);
        const sign = new THREE.Mesh(signGeometry, Stadium.tunnelMaterials.sign);
        sign.position.set(0, 3.5, 22.1);
        tunnelGroup.add(sign);
        
        this.scene.add(tunnelGroup);
    }

    createProfessionalBenches() {
        const benchPositions = [
            { x: -15, z: 15, team: 'Argentina' },
            { x: 15, z: 15, team: 'Francia' }
        ];
        
        benchPositions.forEach(pos => {
            const benchGroup = new THREE.Group();
            
            // Banco principal
            const benchGeometry = new THREE.BoxGeometry(10, 0.6, 2);
            const benchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const bench = new THREE.Mesh(benchGeometry, benchMaterial);
            bench.position.y = 0.3;
            benchGroup.add(bench);
            
            // Respaldos
            const backrestGeometry = new THREE.BoxGeometry(10, 1.5, 0.2);
            const backrest = new THREE.Mesh(backrestGeometry, benchMaterial);
            backrest.position.set(0, 1.05, -0.9);
            benchGroup.add(backrest);
            
            // Techo del banco
            const roofGeometry = new THREE.BoxGeometry(12, 0.2, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(0, 3, 0);
            benchGroup.add(roof);
            
            // Postes de soporte
            const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            
            [-5, 0, 5].forEach(postX => {
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(postX, 1.5, -1.5);
                benchGroup.add(post);
            });
            
            // Letrero del equipo simple sin textura
            const teamSignGeometry = new THREE.PlaneGeometry(8, 1);
            const teamColor = pos.team === 'Argentina' ? 0x87CEEB : 0x002395;
            const teamSignMaterial = new THREE.MeshBasicMaterial({ color: teamColor });
            const teamSign = new THREE.Mesh(teamSignGeometry, teamSignMaterial);
            teamSign.position.set(0, 2, -1.1);
            benchGroup.add(teamSign);
            
            benchGroup.position.set(pos.x, 0, pos.z);
            this.scene.add(benchGroup);
        });
    }

    createTechnicalArea() {
        // √Årea t√©cnica marcada en el suelo
        const technicalAreaGeometry = new THREE.PlaneGeometry(20, 8);
        const technicalAreaMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            transparent: true,
            opacity: 0.1
        });
        
        const technicalArea = new THREE.Mesh(technicalAreaGeometry, technicalAreaMaterial);
        technicalArea.rotation.x = -Math.PI / 2;
        technicalArea.position.set(0, 0.01, 12);
        this.scene.add(technicalArea);
        
        // L√≠neas del √°rea t√©cnica
        this.createFieldLine(-10, 0, 8, 0.1, 8, 'vertical');
        this.createFieldLine(10, 0, 8, 0.1, 8, 'vertical');
        this.createFieldLine(0, 0, 16, 20, 0.1, 'horizontal');
    }

    createPerimeterAdvertising() {
        const ads = [
            'COCA-COLA', 'ADIDAS', 'VISA', 'MASTERCARD', 
            'QATAR 2022', 'FIFA', 'NIKE', 'PEPSI'
        ];
        
        // Publicidad detr√°s del arco
        for (let i = 0; i < 6; i++) {
            this.createAdvertisingBoard(-15 + i * 5, 0.5, -20, ads[i % ads.length]);
        }
        
        // Publicidad lateral
        for (let i = 0; i < 4; i++) {
            this.createAdvertisingBoard(-25, 0.5, -10 + i * 5, ads[(i + 2) % ads.length]);
            this.createAdvertisingBoard(25, 0.5, -10 + i * 5, ads[(i + 4) % ads.length]);
        }
    }

    createAdvertisingBoard(x, y, z, text) {
        const boardGroup = new THREE.Group();
        
        // Reutilizar materiales de publicidad
        if (!Stadium.adMaterials) {
            Stadium.adMaterials = {
                support: new THREE.MeshLambertMaterial({ color: 0x666666 }),
                boards: [
                    new THREE.MeshBasicMaterial({ color: 0xFF0000 }), // Rojo
                    new THREE.MeshBasicMaterial({ color: 0x0066FF }), // Azul
                    new THREE.MeshBasicMaterial({ color: 0x00AA00 }), // Verde
                    new THREE.MeshBasicMaterial({ color: 0xFF6600 }), // Naranja
                    new THREE.MeshBasicMaterial({ color: 0x9900CC })  // Morado
                ]
            };
        }
        
        // Soporte
        const supportGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
        const support = new THREE.Mesh(supportGeometry, Stadium.adMaterials.support);
        support.position.y = 0.5;
        boardGroup.add(support);
        
        // Tablero publicitario simple con color
        const boardGeometry = new THREE.PlaneGeometry(4, 0.8);
        const randomMaterial = Stadium.adMaterials.boards[Math.floor(Math.random() * Stadium.adMaterials.boards.length)];
        const board = new THREE.Mesh(boardGeometry, randomMaterial);
        board.position.y = 1;
        boardGroup.add(board);
        
        boardGroup.position.set(x, y, z);
        this.scene.add(boardGroup);
    }

    createTVCameras() {
        const cameraPositions = [
            { x: 0, y: 8, z: -25, target: [0, 2, -10] },
            { x: -20, y: 6, z: 0, target: [0, 2, -10] },
            { x: 20, y: 6, z: 0, target: [0, 2, -10] },
        ];
        
        cameraPositions.forEach(pos => {
            const cameraGroup = new THREE.Group();
            
            // Base de la c√°mara
            const baseGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.5);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            cameraGroup.add(base);
            
            // C√°mara
            const cameraGeometry = new THREE.BoxGeometry(0.8, 0.4, 1.2);
            const cameraMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            const camera = new THREE.Mesh(cameraGeometry, cameraMaterial);
            camera.position.y = 0.5;
            cameraGroup.add(camera);
            
            // Lente
            const lensGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.3);
            const lensMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const lens = new THREE.Mesh(lensGeometry, lensMaterial);
            lens.rotation.x = Math.PI / 2;
            lens.position.set(0, 0.5, 0.75);
            cameraGroup.add(lens);
            
            cameraGroup.position.set(pos.x, pos.y, pos.z);
            
            // Rotar la c√°mara hacia su objetivo
            cameraGroup.lookAt(pos.target[0], pos.target[1], pos.target[2]);
            
            this.scene.add(cameraGroup);
        });
    }

    createScreen(x, y, z) {
        const screenGroup = new THREE.Group();
        
        // Marco de la pantalla
        const frameGeometry = new THREE.BoxGeometry(8, 4.5, 0.2);
        const frameMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
        const frame = new THREE.Mesh(frameGeometry, frameMaterial);
        screenGroup.add(frame);
        
        // Pantalla
        const screenGeometry = new THREE.PlaneGeometry(7.5, 4);
        const screenMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x001122,
            emissive: 0x001122,
            emissiveIntensity: 0.3
        });
        const screen = new THREE.Mesh(screenGeometry, screenMaterial);
        screen.position.z = 0.11;
        screenGroup.add(screen);
        
        screenGroup.position.set(x, y, z);
        this.scene.add(screenGroup);
        
        // Animaci√≥n de parpadeo de la pantalla
        gsap.to(screenMaterial, {
            emissiveIntensity: 0.6,
            duration: 2 + Math.random(),
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
    }

    createTunnel() {
        const tunnelGeometry = new THREE.BoxGeometry(4, 3, 8);
        const tunnelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
        tunnel.position.set(0, 1.5, 25);
        this.scene.add(tunnel);
    }

    createBenches() {
        // Banco local
        const benchGeometry = new THREE.BoxGeometry(8, 0.5, 1);
        const benchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        
        const homeBench = new THREE.Mesh(benchGeometry, benchMaterial);
        homeBench.position.set(-10, 0.25, 8);
        this.scene.add(homeBench);
        
        // Banco visitante
        const awayBench = new THREE.Mesh(benchGeometry, benchMaterial);
        awayBench.position.set(10, 0.25, 8);
        this.scene.add(awayBench);
    }

    // M√©todo para crear ambiente de final del mundo
    createWorldCupFinalAtmosphere() {
        console.log('üèÜ Creando ambiente de final del mundo...');
        
        // Efectos de luces adicionales
        this.createAtmosphericLights();
        
        // Confeti en el aire
        this.createConfetti();
        
        // Humo de bengalas
        this.createSmoke();
        
        console.log('‚úÖ Ambiente de final creado');
    }

    createAtmosphericLights() {
        // Luces de colores para ambiente
        const colors = [0x87CEEB, 0x0055AA, 0xFFFFFF];
        
        for (let i = 0; i < 6; i++) {
            const light = new THREE.PointLight(colors[i % colors.length], 0.5, 30);
            light.position.set(
                (Math.random() - 0.5) * 60,
                8 + Math.random() * 5,
                -20 + Math.random() * 40
            );
            this.scene.add(light);
            
            // Animaci√≥n de intensidad
            gsap.to(light, {
                intensity: 1.0,
                duration: 1 + Math.random(),
                ease: 'sine.inOut',
                yoyo: true,
                repeat: -1
            });
        }
    }

    createConfetti() {
        const confettiGroup = new THREE.Group();
        
        // Reutilizar geometr√≠a y materiales para confeti
        if (!Stadium.confettiMaterials) {
            const confettiGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.02);
            Stadium.confettiMaterials = {
                geometry: confettiGeometry,
                materials: [
                    new THREE.MeshBasicMaterial({ color: 0x87CEEB }),
                    new THREE.MeshBasicMaterial({ color: 0x0055AA }),
                    new THREE.MeshBasicMaterial({ color: 0xFFD700 }),
                    new THREE.MeshBasicMaterial({ color: 0xFF0000 }),
                    new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
                ]
            };
        }
        
        // Reducir cantidad de confeti para mejor rendimiento
        for (let i = 0; i < 50; i++) {
            const material = Stadium.confettiMaterials.materials[Math.floor(Math.random() * Stadium.confettiMaterials.materials.length)];
            const confetti = new THREE.Mesh(Stadium.confettiMaterials.geometry, material);
            
            confetti.position.set(
                (Math.random() - 0.5) * 80,
                15 + Math.random() * 10,
                (Math.random() - 0.5) * 60
            );
            
            confettiGroup.add(confetti);
            
            // Animaci√≥n de ca√≠da optimizada
            gsap.to(confetti.position, {
                y: -2,
                duration: 8 + Math.random() * 4,
                ease: 'none',
                repeat: -1,
                delay: Math.random() * 5
            });
            
            gsap.to(confetti.rotation, {
                z: Math.PI * 2,
                duration: 2 + Math.random(),
                ease: 'none',
                repeat: -1
            });
        }
        
        this.scene.add(confettiGroup);
    }

    createSmoke() {
        // Humo simple usando part√≠culas
        const smokeGroup = new THREE.Group();
        const smokeGeometry = new THREE.SphereGeometry(0.5);
        const smokeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x666666, 
            transparent: true, 
            opacity: 0.3 
        });
        
        // Humo en las gradas
        for (let i = 0; i < 20; i++) {
            const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
            smoke.position.set(
                (Math.random() - 0.5) * 40,
                8 + Math.random() * 3,
                -22 + Math.random() * 5
            );
            
            smokeGroup.add(smoke);
            
            // Animaci√≥n de dispersi√≥n
            gsap.to(smoke.position, {
                y: smoke.position.y + 5,
                duration: 3 + Math.random() * 2,
                ease: 'power1.out',
                repeat: -1,
                yoyo: true
            });
            
            gsap.to(smoke.material, {
                opacity: 0.1,
                duration: 2 + Math.random(),
                ease: 'sine.inOut',
                repeat: -1,
                yoyo: true
            });
        }
        
        this.scene.add(smokeGroup);
    }

    // M√©todo para aumentar la intensidad durante momentos clave
    intensifyAtmosphere() {
        console.log('üî• Intensificando ambiente del estadio...');
        
        // Acelerar animaciones de multitud (limitado para rendimiento)
        const crowdSample = this.crowd.slice(0, Math.min(this.crowd.length, 100));
        crowdSample.forEach(person => {
            gsap.to(person.position, {
                y: person.position.y + 0.5,
                duration: 0.3,
                ease: 'power2.out',
                yoyo: true,
                repeat: 5
            });
        });
        
        // Intensificar luces principales solamente
        const mainLights = this.lights.slice(0, 4);
        mainLights.forEach(light => {
            gsap.to(light, {
                intensity: 1.5,
                duration: 0.5,
                ease: 'power2.out',
                yoyo: true,
                repeat: 3
            });
        });
    }

    // M√©todo para optimizar el rendimiento si es necesario
    optimizeForPerformance() {
        console.log('üîß Optimizando rendimiento del estadio (preservando calidad del juego)...');
        
        // Reducir multitud m√°s agresivamente - solo elementos del estadio
        if (this.crowd.length > 200) {
            const excessCrowd = this.crowd.splice(200);
            excessCrowd.forEach(person => {
                person.parent?.remove(person);
            });
            console.log(`Reducidas ${excessCrowd.length} personas para mejorar rendimiento`);
        }
        
        // Reducir luces del estadio (NO afecta arco, arquero, pelota)
        if (this.lights.length > 6) {
            const excessLights = this.lights.splice(6);
            excessLights.forEach(light => {
                this.scene.remove(light);
                if (light.target) this.scene.remove(light.target);
            });
            console.log(`Reducidas ${excessLights.length} luces para mejorar rendimiento`);
        }
        
        // Reducir banderas si hay demasiadas
        if (this.flags.length > 6) {
            const excessFlags = this.flags.splice(6);
            excessFlags.forEach(flag => {
                this.scene.remove(flag);
            });
            console.log(`Reducidas ${excessFlags.length} banderas para mejorar rendimiento`);
        }
        
        // Configurar nivel de detalle m√°s bajo para elementos lejanos
        this.setLowDetailForDistantElements();
        
        console.log('‚úÖ Optimizaci√≥n del estadio completada (elementos del juego preservados)');
    }

    setLowDetailForDistantElements() {
        // Reducir la frecuencia de animaciones de multitud
        const crowdAnimationSample = this.crowd.filter((_, index) => index % 3 === 0); // Solo 1 de cada 3
        
        crowdAnimationSample.forEach(person => {
            // Pausar animaciones de personas lejanas
            gsap.killTweensOf(person.position);
            gsap.killTweensOf(person.rotation);
        });
        
        console.log(`Optimizadas animaciones de ${this.crowd.length - crowdAnimationSample.length} personas lejanas`);
    }
}
</file>

<file path="src/javascript.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path fill="#F7DF1E" d="M0 0h256v256H0V0Z"></path><path d="m67.312 213.932l19.59-11.856c3.78 6.701 7.218 12.371 15.465 12.371c7.905 0 12.89-3.092 12.89-15.12v-81.798h24.057v82.138c0 24.917-14.606 36.259-35.916 36.259c-19.245 0-30.416-9.967-36.087-21.996m85.07-2.576l19.588-11.341c5.157 8.421 11.859 14.607 23.715 14.607c9.969 0 16.325-4.984 16.325-11.858c0-8.248-6.53-11.17-17.528-15.98l-6.013-2.58c-17.357-7.387-28.87-16.667-28.87-36.257c0-18.044 13.747-31.792 35.228-31.792c15.294 0 26.292 5.328 34.196 19.247l-18.732 12.03c-4.125-7.389-8.591-10.31-15.465-10.31c-7.046 0-11.514 4.468-11.514 10.31c0 7.217 4.468 10.14 14.778 14.608l6.014 2.577c20.45 8.765 31.963 17.7 31.963 37.804c0 21.654-17.012 33.51-39.867 33.51c-22.339 0-36.774-10.654-43.819-24.574"></path></svg>
</file>

<file path="src/main.js">
import * as THREE from 'three';
import SceneManager from './experience/SceneManager';

const canvas = document.querySelector('#webgl');
const sceneManager = new SceneManager(canvas);

const clock = new THREE.Clock();

function animate() {
    const deltaTime = clock.getDelta();
    sceneManager.update(deltaTime);
    requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', () => sceneManager.onResize());
</file>

<file path="package.json">
{
  "name": "final-penalty-kick",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "vite": "^5.4.10"
  },
  "dependencies": {
    "eventemitter3": "^5.0.1",
    "gsap": "^3.13.0",
    "three": "^0.180.0"
  }
}
</file>

<file path="README.md">
# Three.js - Penal de la Final del Mundo üéÆüñêÔ∏è

Este proyecto es una simulaci√≥n completa de un penal decisivo en una final del mundo, desarrollado con Three.js y Vite. La experiencia incluye movimiento en primera persona, una IA para el arquero, m√∫ltiples desenlaces, un arco narrativo y **control por gestos usando MediaPipe**.

## ‚ú® Novedades: Control por Gestos

¬°Ahora puedes jugar usando gestos de mano en tiempo real! El sistema detecta:

- **üëÜ Dedo √≠ndice extendido**: Apunta hacia donde quieres disparar
- **üëä Pu√±o cerrado**: Comienza a cargar la potencia del tiro
- **‚úã Abrir la mano**: ¬°Dispara la pelota!

## Requisitos

- Node.js (v16 o superior)
- npm
- **C√°mara web** (para control por gestos)
- Navegador moderno con soporte para MediaPipe

## Instalaci√≥n y Ejecuci√≥n

1.  **Clonar el repositorio:**
    ```bash
    git clone https://...
    cd final-penalty-kick
    ```

2.  **Colocar los assets (OBLIGATORIO):**
    Descarga los modelos 3D y los archivos de audio y col√≥calos en la carpeta `public/` siguiendo esta estructura:
    
    ```
    public/
    ‚îú‚îÄ‚îÄ models/
    ‚îÇ   ‚îú‚îÄ‚îÄ arco.glb
    ‚îÇ   ‚îú‚îÄ‚îÄ pelota.glb
    ‚îÇ   ‚îú‚îÄ‚îÄ jugador.glb
    ‚îÇ   ‚îî‚îÄ‚îÄ arquero.glb
    ‚îî‚îÄ‚îÄ audio/
        ‚îî‚îÄ‚îÄ montiel.weba (audio del penal)
    ```

3.  **Instalar dependencias:**
    ```bash
    npm install
    ```

4.  **Iniciar el servidor de desarrollo:**
    ```bash
    npm run dev
    ```
    Abre la URL que aparece en la consola (generalmente `http://localhost:5173`).

## üéÆ Controles

### Modo Cl√°sico (Teclado + Mouse)

-   **WASD:** Mover al jugador en la fase de `PRE_PENAL`.
-   **Mouse:** Apuntar la direcci√≥n del tiro.
-   **A/D:** Perfilar el tiro (movimiento lateral sutil) en la fase de `AIMING`.
-   **Mantener ESPACIO:** Cargar la barra de fuerza.
-   **Soltar ESPACIO:** Patear la pelota.
-   **SHIFT:** Correr en la fase de `PRE_PENAL`.
-   **G:** Activar/desactivar control por gestos.

### Modo Gestos (Experimental) üñêÔ∏è

1. **Activar el modo**: Haz clic en "Activar Control por Gestos" en el panel de opciones
2. **Permitir acceso a la c√°mara** cuando el navegador lo solicite
3. **Posiciona tu mano** frente a la c√°mara (aparecer√° un preview en la esquina superior izquierda)
4. **Gestos disponibles**:
   - üëÜ **Apuntar**: Extiende solo tu dedo √≠ndice (otros dedos cerrados)
   - üëä **Cargar**: Cierra el pu√±o completamente
   - ‚úã **Disparar**: Abre la mano despu√©s de haber cargado

**Consejos para mejor detecci√≥n:**
- Mant√©n tu mano a 30-50cm de la c√°mara
- Aseg√∫rate de tener buena iluminaci√≥n
- Fondo simple sin muchas distracciones
- Haz gestos claros y deliberados

## Opciones en Pantalla

-   **Slider "Presi√≥n":** Aumenta la imprecisi√≥n del tiro. Un valor m√°s alto hace m√°s dif√≠cil anotar.
-   **Bot√≥n "Activar Control por Gestos":** Activa/desactiva el modo de control por gestos con c√°mara.

## Stack Tecnol√≥gico

-   **Motor 3D:** Three.js (r180)
-   **Bundler:** Vite
-   **Animaci√≥n:** GSAP
-   **Detecci√≥n de Gestos:** MediaPipe Hands (Google)
-   **M√≥dulos de Three.js:** `GLTFLoader`, `PointerLockControls`
-   **Audio:** WebAudio API (gestionada a trav√©s de Three.js Audio)
-   **Eventos:** EventEmitter3

## Estructura del Proyecto

```
src/
‚îú‚îÄ‚îÄ experience/
‚îÇ   ‚îú‚îÄ‚îÄ Assets.js          # Carga de modelos 3D
‚îÇ   ‚îú‚îÄ‚îÄ Audio.js           # Sistema de audio
‚îÇ   ‚îú‚îÄ‚îÄ GoalkeeperAI.js    # IA del arquero
‚îÇ   ‚îú‚îÄ‚îÄ Input.js           # Gesti√≥n de controles (teclado + gestos)
‚îÇ   ‚îú‚îÄ‚îÄ GestureManager.js  # üÜï Detecci√≥n de gestos con MediaPipe
‚îÇ   ‚îú‚îÄ‚îÄ SceneManager.js    # Coordinador principal
‚îÇ   ‚îú‚îÄ‚îÄ ShotModel.js       # F√≠sica del tiro
‚îÇ   ‚îú‚îÄ‚îÄ States.js          # M√°quina de estados del juego
‚îÇ   ‚îî‚îÄ‚îÄ UI.js              # Interfaz de usuario
‚îî‚îÄ‚îÄ main.js                # Punto de entrada
```

## Arquitectura del Sistema de Gestos

El sistema de gestos utiliza **MediaPipe Hands** para detectar y clasificar gestos en tiempo real:

1. **Captura de Video**: Accede a la c√°mara web del usuario
2. **Detecci√≥n de Landmarks**: MediaPipe identifica 21 puntos clave de la mano
3. **Clasificaci√≥n de Gestos**: Algoritmo personalizado interpreta los landmarks
4. **Emisi√≥n de Eventos**: Los gestos detectados disparan eventos que el juego escucha
5. **Integraci√≥n con Input Manager**: Los eventos de gestos se integran con los controles tradicionales

## Troubleshooting

### La c√°mara no funciona
- Verifica que tu navegador tenga permisos para acceder a la c√°mara
- Aseg√∫rate de estar usando HTTPS (o localhost)
- Revisa la consola del navegador para errores

### Los gestos no se detectan correctamente
- Mejora la iluminaci√≥n de tu espacio
- Acerca o aleja tu mano de la c√°mara
- Evita fondos muy ocupados o con muchos colores
- Aseg√∫rate de que toda tu mano est√© visible en el cuadro

### El juego va lento con gestos activados
- MediaPipe es computacionalmente intensivo
- Cierra otras pesta√±as del navegador
- Considera usar el modo de teclado si tu PC es m√°s antigua

## Futuras Mejoras

- [ ] Calibraci√≥n personalizada de gestos
- [ ] Soporte para m√∫ltiples gestos personalizados
- [ ] Feedback visual mejorado para reconocimiento de gestos
- [ ] Modo de entrenamiento de gestos
- [ ] Soporte para control de voz adicional

## Cr√©ditos

- **Motor 3D**: Three.js
- **Detecci√≥n de Gestos**: Google MediaPipe
- **Audio del penal**: Transmisi√≥n original

---

**¬°Disfruta del penal m√°s inmersivo de tu vida! ‚öΩüî•**
</file>

<file path="src/experience/Assets.js">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import EventEmitter from 'eventemitter3';

export default class Assets extends EventEmitter {
    constructor() {
        super();
        this.manager = new THREE.LoadingManager(
            () => this.emit('loaded'),
            (url, itemsLoaded, itemsTotal) => {
                const progress = itemsLoaded / itemsTotal;
                this.emit('progress', progress);
            }
        );
        this.gltfLoader = new GLTFLoader(this.manager);
        this.items = {};

        this.load();
    }

    load() {
        const modelsToLoad = [
            { name: 'arco', path: '/models/arco.glb' },
            { name: 'pelota', path: '/models/pelota.glb' },
            { name: 'jugador', path: '/models/jugador.glb' },
            { name: 'arquero', path: '/models/elshenawy.glb' },
            
        ];

        for (const model of modelsToLoad) {
            this.gltfLoader.load(model.path, (gltf) => {
                this.items[model.name] = gltf;
            });
        }
    }

    get(name) {
        return this.items[name];
    }
}
</file>

<file path="src/style.css">
body, html { 
    margin: 0; 
    padding: 0; 
    overflow: hidden; 
    background: #000; 
    font-family: 'Helvetica', sans-serif; 
}

#webgl { 
    position: fixed; 
    top: 0; 
    left: 0; 
    outline: none; 
}

#ui-container { 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    color: white; 
    pointer-events: none; 
}

.overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.7);
    text-align: center;
    transition: opacity 1s ease;
}

.overlay.active { 
    opacity: 1; 
    pointer-events: all; 
}

.overlay.hidden { 
    opacity: 0; 
    pointer-events: none; 
}

.overlay h1 { 
    font-size: 4rem; 
    margin: 0; 
}

.overlay h2 { 
    font-size: 3rem; 
    text-shadow: 0 0 10px #fff; 
}

.overlay p { 
    font-size: 1.5rem; 
}

.overlay button {
    padding: 20px 50px;
    font-size: 1.8rem;
    font-weight: bold;
    background: #00ff00;
    color: #000;
    border: 3px solid #fff;
    cursor: pointer;
    margin-top: 30px;
    pointer-events: all;
    transition: all 0.3s;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
    text-transform: uppercase;
}

.overlay button:hover { 
    background: #00cc00;
    transform: scale(1.1);
    box-shadow: 0 0 30px rgba(0, 255, 0, 1);
}

#hud { 
    width: 100%; 
    height: 100%; 
}

#power-bar-container {
    position: absolute;
    bottom: 50px;
    left: 50%;
    transform: translateX(-50%);
    width: 300px;
    height: 20px;
    background: rgba(0,0,0,0.5);
    border: 2px solid white;
    padding: 2px;
    border-radius: 5px;
}

#power-bar {
    width: 0%;
    height: 100%;
    background: linear-gradient(90deg, #adff2f, #ffff00, #ff4500);
    border-radius: 3px;
    transition: width 0.05s;
}

#reticle {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    opacity: 0.5;
}

.controls-info {
    position: absolute;
    bottom: 10px;
    left: 10px;
    opacity: 0.7;
    font-size: 14px;
}

#options-panel {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    padding: 15px;
    border-radius: 8px;
    pointer-events: all;
    min-width: 200px;
    border: 1px solid rgba(255,255,255,0.2);
}

#options-panel button {
    pointer-events: all;
}

#options-panel button:hover {
    transform: scale(1.02);
}
</file>

<file path="src/experience/Audio.js">
import * as THREE from 'three';
import gsap from 'gsap';

export default class AudioManager {
    constructor() {
        this.listener = null;
        this.sounds = {};
        // Audio de penal y estadio
        this.audioSources = {
            montiel: [
                './audio/montiel.weba',
                '/audio/montiel.weba',
                'audio/montiel.weba',
                './public/audio/montiel.weba',
                '/public/audio/montiel.weba'
            ]
        };
        
        // Crear sonidos sint√©ticos para el estadio
        this.crowdAudio = null;
        this.ambientAudio = null;
        
        // Inicializar audio autom√°ticamente
        console.log('üéµ AudioManager constructor - auto-initializing...');
        this.autoInit();
    }

    autoInit() {
        try {
            this.listener = new THREE.AudioListener();
            console.log('AudioListener created automatically');
            
            // Intentar cargar audios inmediatamente
            Object.entries(this.audioSources).forEach(([name, paths]) => {
                const sound = new THREE.Audio(this.listener);
                this.sounds[name] = sound;
                
                console.log(`Auto-loading audio: ${name}`);
                this.tryLoadAudio(name, paths, 0, sound);
            });
            
            // Crear sonidos sint√©ticos del estadio
            this.createSyntheticStadiumAudio();
        } catch (error) {
            console.error('Error in auto-init:', error);
        }
    }

    init(camera = null) {
        console.log('üéµ AudioManager.init() called');
        console.log('Camera provided:', !!camera);
        
        // La creaci√≥n del AudioContext debe estar tras un gesto del usuario
        this.listener = new THREE.AudioListener();
        console.log('AudioListener created:', this.listener);
        
        // Si se proporciona una c√°mara, a√±adir el listener a ella
        if (camera) {
            camera.add(this.listener);
            console.log('AudioListener added to camera');
        }
        
        const audioLoader = new THREE.AudioLoader();
        console.log('AudioLoader created:', audioLoader);
        console.log('Audio sources to load:', this.audioSources);

        Object.entries(this.audioSources).forEach(([name, paths]) => {
            const sound = new THREE.Audio(this.listener);
            this.sounds[name] = sound;
            
            console.log(`Attempting to load audio: ${name}`);
            console.log(`Available paths:`, paths);
            
            // Intentar cargar desde la primera ruta
            this.tryLoadAudio(name, paths, 0, sound);
        });
    }

    play(name, loop = false) {
        const sound = this.sounds[name];
        if (sound && sound.buffer && !sound.isPlaying) {
            sound.setLoop(loop);
            try {
                sound.play();
            } catch (error) {
                console.warn(`Could not play sound: ${name}`, error);
            }
        } else if (!sound) {
            console.warn(`Sound not found: ${name}`);
        }
    }

    stop(name) {
        const sound = this.sounds[name];
        if (sound && sound.isPlaying) {
            sound.stop();
        }
    }

    fade(name, targetVolume, duration) {
        const sound = this.sounds[name];
        if (sound) {
            gsap.to(sound, { volume: targetVolume, duration: duration });
        }
    }

    ensureMontielReady() {
        const montiel = this.sounds['montiel'];
        console.log('üîä Checking montiel audio...', !!montiel, !!montiel?.buffer);
        
        if (montiel && montiel.buffer) {
            console.log('‚úÖ Montiel audio is ready!');
            return true;
        } else {
            console.warn('‚ö†Ô∏è Montiel audio not ready yet');
            return false;
        }
    }

    // Activar audio context despu√©s de interacci√≥n del usuario
    activateAudioContext() {
        const montiel = this.sounds['montiel'];
        if (montiel && montiel.buffer) {
            // Reproducir y pausar inmediatamente para activar el contexto
            try {
                montiel.setVolume(0); // Volumen 0 para que no se escuche
                montiel.play();
                setTimeout(() => {
                    montiel.stop();
                    montiel.setVolume(0.8); // Restaurar volumen para uso posterior
                    console.log('üéµ Audio context activated! Montiel ready to play.');
                }, 100);
            } catch (error) {
                console.error('Error activating audio context:', error);
            }
        }
    }

    playMontiel() {
        const montiel = this.sounds['montiel'];
        console.log('üéôÔ∏è Attempting to play Montiel...', !!montiel, !!montiel?.buffer);
        
        if (montiel && montiel.buffer) {
            if (montiel.isPlaying) {
                montiel.stop(); // Detener si ya est√° sonando
                console.log('üîÑ Stopped previous Montiel playback');
            }
            
            montiel.setVolume(0.8); // Volumen alto para Montiel
            
            try {
                montiel.play();
                console.log('üéôÔ∏è ¬°MONTIEL SUENA! Volume:', montiel.volume);
            } catch (error) {
                console.error('‚ùå Error playing Montiel audio:', error);
                // Intentar despu√©s de un peque√±o delay
                setTimeout(() => {
                    try {
                        montiel.play();
                        console.log('üéôÔ∏è ¬°MONTIEL SUENA EN RETRY!');
                    } catch (e) {
                        console.error('‚ùå Retry failed:', e);
                    }
                }, 500);
            }
        } else {
            console.warn('‚ö†Ô∏è Montiel audio not ready yet');
        }
    }

    // M√©todo de diagn√≥stico
    getAudioStatus() {
        const status = {};
        Object.entries(this.sounds).forEach(([name, sound]) => {
            status[name] = {
                loaded: !!sound.buffer,
                playing: sound.isPlaying,
                volume: sound.volume,
                context: sound.context?.state || 'unknown'
            };
        });
        console.log('üìä Audio Status Details:', status);
        return status;
    }

    createSyntheticStadiumAudio() {
        if (!this.listener) return;
        
        console.log('üéµ Creating synthetic stadium audio...');
        
        // Crear audio de multitud usando Web Audio API
        const audioContext = this.listener.context;
        
        if (audioContext) {
            this.createCrowdNoise(audioContext);
            this.createAmbientNoise(audioContext);
        }
    }

    createCrowdNoise(audioContext) {
        try {
            // Crear un buffer para ruido de multitud
            const bufferSize = audioContext.sampleRate * 2; // 2 segundos
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            // Generar ruido rosa filtrado que simula una multitud
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                const pink = white * (0.02 + 0.98 * Math.sin(i * 0.001)); // Filtro simple
                data[i] = pink * 0.3; // Volumen moderado
            }
            
            // Crear el audio usando Three.js
            this.crowdAudio = new THREE.Audio(this.listener);
            this.crowdAudio.setBuffer(buffer);
            this.crowdAudio.setLoop(true);
            this.crowdAudio.setVolume(0.2);
            
            console.log('‚úÖ Crowd noise created');
        } catch (error) {
            console.error('Error creating crowd noise:', error);
        }
    }

    createAmbientNoise(audioContext) {
        try {
            // Crear ambiente del estadio (viento, eco, etc.)
            const bufferSize = audioContext.sampleRate * 3; // 3 segundos
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            // Generar ruido ambiente muy suave
            for (let i = 0; i < bufferSize; i++) {
                const ambient = (Math.random() * 2 - 1) * 0.05; // Muy suave
                const echo = Math.sin(i * 0.0001) * 0.02; // Efecto de eco
                data[i] = ambient + echo;
            }
            
            this.ambientAudio = new THREE.Audio(this.listener);
            this.ambientAudio.setBuffer(buffer);
            this.ambientAudio.setLoop(true);
            this.ambientAudio.setVolume(0.1);
            
            console.log('‚úÖ Ambient noise created');
        } catch (error) {
            console.error('Error creating ambient noise:', error);
        }
    }

    playStadiumAmbient() {
        console.log('üèüÔ∏è Playing stadium ambient sounds...');
        
        if (this.crowdAudio && !this.crowdAudio.isPlaying) {
            try {
                this.crowdAudio.play();
                console.log('‚úÖ Crowd noise playing');
            } catch (error) {
                console.error('Error playing crowd noise:', error);
            }
        }
        
        if (this.ambientAudio && !this.ambientAudio.isPlaying) {
            try {
                this.ambientAudio.play();
                console.log('‚úÖ Ambient noise playing');
            } catch (error) {
                console.error('Error playing ambient noise:', error);
            }
        }
    }

    stopStadiumAmbient() {
        if (this.crowdAudio && this.crowdAudio.isPlaying) {
            this.crowdAudio.stop();
        }
        if (this.ambientAudio && this.ambientAudio.isPlaying) {
            this.ambientAudio.stop();
        }
    }

    intensifyStadiumAudio() {
        console.log('üî• Intensifying stadium audio...');
        
        if (this.crowdAudio) {
            gsap.to(this.crowdAudio, {
                volume: 0.4,
                duration: 0.5,
                ease: 'power2.out',
                yoyo: true,
                repeat: 3,
                onComplete: () => {
                    this.crowdAudio.setVolume(0.2);
                }
            });
        }
    }

    tryLoadAudio(name, paths, pathIndex, sound) {
        if (pathIndex >= paths.length) {
            console.error(`‚ùå All paths failed for audio: ${name}`);
            return;
        }

        const path = paths[pathIndex];
        const audioLoader = new THREE.AudioLoader();
        
        console.log(`üîÑ Trying path ${pathIndex + 1}/${paths.length}: ${path}`);
        
        audioLoader.load(path,
            // Success callback
            (buffer) => {
                sound.setBuffer(buffer);
                sound.setVolume(0.5);
                
                if (name === 'crowd') {
                    sound.setLoop(true);
                    sound.setVolume(0.3);
                    console.log('‚úÖ Crowd audio loaded and configured successfully');
                }
                console.log(`‚úÖ Audio ${name} loaded successfully from: ${path}`);
            },
            // Progress callback
            (progress) => {
                if (progress.total > 0) {
                    const percent = Math.round(progress.loaded / progress.total * 100);
                    console.log(`‚è≥ Loading ${name}: ${percent}%`);
                }
            },
            // Error callback
            (error) => {
                console.warn(`‚ùå Failed to load ${name} from: ${path}`);
                console.log(`Trying next path...`);
                
                // Intentar con la siguiente ruta
                this.tryLoadAudio(name, paths, pathIndex + 1, sound);
            }
        );
    }

    loadAudioWithAlternatePath(name, alternatePath, sound) {
        const audioLoader = new THREE.AudioLoader();
        console.log(`üîÑ Trying to load ${name} from alternate path: ${alternatePath}`);
        
        audioLoader.load(alternatePath,
            // Success callback
            (buffer) => {
                sound.setBuffer(buffer);
                sound.setVolume(0.5);
                
                if (name === 'crowd') {
                    sound.setLoop(true);
                    sound.setVolume(0.3);
                    console.log('‚úÖ Crowd audio loaded successfully from alternate path');
                }
                console.log(`‚úÖ Audio ${name} loaded from alternate path`);
            },
            // Progress callback
            (progress) => {
                if (progress.total > 0) {
                    const percent = Math.round(progress.loaded / progress.total * 100);
                    console.log(`‚è≥ Loading ${name} (alternate): ${percent}%`);
                }
            },
            // Error callback
            (error) => {
                console.error(`‚ùå Failed to load ${name} from alternate path too:`, error);
                console.log(`‚ùå Audio ${name} completely failed to load. Check if file exists.`);
            }
        );
    }
}
</file>

<file path="src/experience/Input.js">
import EventEmitter from 'eventemitter3';
import gsap from 'gsap';

export default class InputManager extends EventEmitter {
    constructor() {
        super();
        this.keys = {
            w: false, a: false, s: false, d: false,
            shift: false, space: false
        };
        this.power = 0;
        this.charging = false;
        this.movementEnabled = false;
        
        // Control por gestos
        this.gestureMode = false;
        this.gestureAimTarget = { x: 0.5, y: 0.5 };

        document.addEventListener('keydown', (e) => this.onKey(e.code, true));
        document.addEventListener('keyup', (e) => this.onKey(e.code, false));
    }
    
    enableGestureMode() {
        this.gestureMode = true;
        console.log('üñêÔ∏è Gesture mode enabled');
    }
    
    disableGestureMode() {
        this.gestureMode = false;
        console.log('‚å®Ô∏è Keyboard mode enabled');
    }
    
    isGestureMode() {
        return this.gestureMode;
    }
    
    updateGestureAim(target) {
        // target es {x, y} normalizado (0-1)
        // Convertir a coordenadas √∫tiles para la c√°mara
        this.gestureAimTarget = target;
        this.emit('gesture-aim', target);
    }
    
    startGestureCharge() {
        if (!this.charging) {
            this.charging = true;
            this.power = 0;
            gsap.to(this, { power: 1, duration: 1.5, ease: 'power1.in' });
            this.emit('charge-start');
        }
    }
    
    gestureShoot() {
        if (this.charging) {
            this.charging = false;
            gsap.killTweensOf(this);
            this.emit('kick', this.power);
            this.power = 0;
        }
    }
    
    setMovementEnabled(enabled) {
        this.movementEnabled = enabled;
    }

    onKey(code, isPressed) {
        console.log(`Key Event -> Code: ${code}, Pressed: ${isPressed}, Movement Enabled: ${this.movementEnabled}`);

        switch(code) {
            case 'KeyW':
            case 'ArrowUp':
                if (this.movementEnabled) this.keys.w = isPressed;
                break;
            case 'KeyA':
            case 'ArrowLeft':
                this.keys.a = isPressed;
                break;
            case 'KeyS':
            case 'ArrowDown':
                if (this.movementEnabled) this.keys.s = isPressed;
                break;
            case 'KeyD':
            case 'ArrowRight':
                this.keys.d = isPressed;
                break;
            case 'ShiftLeft':
                this.keys.shift = isPressed;
                break;
            case 'KeyT':
                if (isPressed) {
                    this.emit('test-audio');
                }
                break;
            case 'KeyG': // Toggle gesture mode
                if (isPressed) {
                    this.emit('toggle-gesture');
                }
                break;
            case 'Space':
                if (!this.gestureMode) { // Solo si no estamos en modo gesture
                    this.handleSpace(isPressed);
                }
                break;
        }
    }

    handleSpace(isPressed) {
        if (isPressed && !this.charging) {
            this.charging = true;
            this.power = 0;
            gsap.to(this, { power: 1, duration: 1.5, ease: 'power1.in' });
        } else if (!isPressed && this.charging) {
            this.charging = false;
            gsap.killTweensOf(this);
            this.emit('kick', this.power);
            this.power = 0;
        }
    }
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Penal - Final del Mundo</title>
    <link rel="stylesheet" href="./src/style.css">
</head>
<body>
    <canvas id="webgl"></canvas>
    
    <div id="ui-container">
        <!-- Pantalla de INTRO -->
        <div id="intro-overlay" class="overlay active">
            <h1>Final del Mundo</h1>
            <p>Minuto 120. El destino en tus pies.</p>
            <button id="start-button">‚ñ∂Ô∏è Empezar</button>
            <div style="margin: 20px 0; font-size: 0.85em; opacity: 0.8; max-width: 700px;">
                <p><strong>ü¶∂ Control con Pie (Autom√°tico):</strong></p>
                <p>La c√°mara detectar√° tu pierna autom√°ticamente</p>
                <p>üéØ <strong>Mueve pie izq/der</strong> ‚Üí Apuntar</p>
                <p>‚¨ÜÔ∏è <strong>Levanta pierna</strong> ‚Üí Cargar potencia (m√°s alto = m√°s potencia)</p>
                <p>‚¨áÔ∏è‚ö° <strong>Baja r√°pido</strong> ‚Üí ¬°DISPARO!</p>
                <p style="font-size: 0.9em; margin-top: 10px;">‚å®Ô∏è <strong>Teclado de respaldo:</strong> ESPACIO para cargar/disparar</p>
            </div>
        </div>

        <!-- HUD del juego -->
        <div id="hud" class="hidden">
            <div id="power-bar-container">
                <div id="power-bar"></div>
            </div>
            <div id="reticle">+</div>
            <div class="controls-info">
                <p id="controls-text">üéØ Mueve pie izq/der ‚Üí Apuntar | ‚¨ÜÔ∏è Levanta pierna ‚Üí Cargar | ‚¨áÔ∏è‚ö° Baja r√°pido ‚Üí DISPARAR</p>
            </div>
        </div>
        
        <!-- Pantalla de EPILOGUE -->
        <div id="epilogue-overlay" class="overlay hidden">
            <h2 id="epilogue-title"></h2>
            <p id="epilogue-message">Un penal no es solo un disparo, es una historia.</p>
            <button id="retry-button">Reintentar</button>
        </div>
    </div>

    <script type="module" src="/src/main.js"></script>
</body>
</html>
</file>

<file path="src/experience/GoalkeeperAI.js">
import * as THREE from 'three';
import gsap from 'gsap';

// Clase para movimientos org√°nicos del arquero
class OrganicMovement {
    static createNaturalPath(startPos, endPos, movementType) {
        const path = new THREE.CurvePath();
        
        // Calcular puntos de control para una curva natural
        const distance = startPos.distanceTo(endPos);
        const midPoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
        
        switch(movementType) {
            case 'step':
                // Para pasos: curva suave lateral
                const stepControl = midPoint.clone();
                stepControl.y += 0.1; // Peque√±a elevaci√≥n natural
                stepControl.x += (endPos.x - startPos.x) * 0.3; // Anticipaci√≥n
                
                const stepCurve = new THREE.QuadraticBezierCurve3(startPos, stepControl, endPos);
                path.add(stepCurve);
                break;
                
            case 'dive':
                // Para zambullidas: curva parab√≥lica realista
                const diveControl1 = startPos.clone();
                diveControl1.y += 0.2; // Impulso inicial hacia arriba
                diveControl1.x += (endPos.x - startPos.x) * 0.2;
                
                const diveControl2 = midPoint.clone();
                diveControl2.y += Math.max(0.1, distance * 0.15); // Arco de vuelo
                
                const diveCurve = new THREE.CubicBezierCurve3(startPos, diveControl1, diveControl2, endPos);
                path.add(diveCurve);
                break;
                
            case 'desperate':
                // Para intentos desesperados: movimiento exagerado
                const desperateControl1 = startPos.clone();
                desperateControl1.y += 0.3;
                desperateControl1.x += (endPos.x - startPos.x) * 0.1;
                
                const desperateControl2 = midPoint.clone();
                desperateControl2.y += 0.4;
                desperateControl2.x += (endPos.x - startPos.x) * 0.8;
                
                const desperateCurve = new THREE.CubicBezierCurve3(startPos, desperateControl1, desperateControl2, endPos);
                path.add(desperateCurve);
                break;
                
            default:
                // Movimiento lineal simple
                const linearCurve = new THREE.LineCurve3(startPos, endPos);
                path.add(linearCurve);
        }
        
        return path;
    }
    
    static animateAlongPath(object, path, duration, rotation = null) {
        const points = path.getPoints(50); // 50 puntos para suavidad
        
        const timeline = gsap.timeline();
        
        // Animar posici√≥n a lo largo del path
        timeline.to({}, {
            duration: duration,
            ease: "power2.out",
            onUpdate: function() {
                const progress = this.progress();
                const targetIndex = Math.floor(progress * (points.length - 1));
                
                if (targetIndex < points.length) {
                    object.position.copy(points[targetIndex]);
                    
                    // Rotaci√≥n natural basada en la direcci√≥n del movimiento
                    if (rotation && targetIndex > 0) {
                        const direction = new THREE.Vector3()
                            .subVectors(points[targetIndex], points[targetIndex - 1])
                            .normalize();
                        
                        if (direction.length() > 0) {
                            const angle = Math.atan2(direction.x, direction.z);
                            object.rotation.y = angle * rotation.intensity;
                        }
                    }
                }
            }
        });
        
        return timeline;
    }
}

export default class GoalkeeperAI {
    constructor(model, mixer = null, clips = null) {
        this.model = model;
        this.mixer = mixer;
        this.clips = clips || {};
        this.currentAction = null;
        this.initialPos = model.position.clone();
        this.state = 'IDLE';
        this.reactionTime = 0.2 + Math.random() * 0.15; // 0.2-0.35s m√°s realista
        
        // Caracter√≠sticas del arquero (aleatorias para variabilidad)
        this.skills = {
            reflexes: 0.6 + Math.random() * 0.3,    // 0.6-0.9 (reflejos)
            positioning: 0.5 + Math.random() * 0.4, // 0.5-0.9 (posicionamiento)
            reach: 0.7 + Math.random() * 0.2        // 0.7-0.9 (alcance)
        };
        
        // Log de animaciones disponibles
        if (this.mixer && Object.keys(this.clips).length > 0) {
            console.log('üé≠ GoalkeeperAI ElShenawy: Animaciones disponibles:', Object.keys(this.clips));
        } else {
            console.log('‚ÑπÔ∏è GoalkeeperAI ElShenawy: Sin animaciones, usando movimiento por c√≥digo');
        }
        
        // L√≠mites del arco ULTRA AMPLIOS para movimiento extremo
        this.goalLimits = {
            minX: -5.0,  // EXTREMADAMENTE amplio
            maxX: 5.0,   // EXTREMADAMENTE amplio
            minY: this.initialPos.y,   
            maxY: this.initialPos.y + 2.0,   // Tambi√©n m√°s alto
            minZ: this.initialPos.z, // Sin movimiento adelante/atr√°s
            maxZ: this.initialPos.z   
        };
        
        this.reset();
    }

    // M√©todos para manejar animaciones del modelo ElShenawy
    playAnimation(animationName, options = {}) {
        if (!this.mixer || !this.clips[animationName]) {
            console.log(`‚ö†Ô∏è Animaci√≥n '${animationName}' no disponible`);
            return false;
        }

        const { loop = false, fadeIn = 0.2, fadeOut = 0.2, timeScale = 1.0 } = options;

        // Detener animaci√≥n actual si existe
        if (this.currentAction) {
            this.currentAction.fadeOut(fadeOut);
        }

        // Reproducir nueva animaci√≥n
        this.currentAction = this.clips[animationName];
        this.currentAction
            .reset()
            .setEffectiveTimeScale(timeScale)
            .setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce)
            .fadeIn(fadeIn)
            .play();

        console.log(`üé≠ Reproduciendo animaci√≥n ElShenawy: ${animationName}`);
        return true;
    }

    stopAnimation() {
        if (this.currentAction) {
            this.currentAction.fadeOut(0.2);
            this.currentAction = null;
        }
    }

    // Intentar usar animaciones espec√≠ficas para acciones del arquero
    playIdleAnimation() {
        // Buscar animaciones de idle/reposo comunes en modelos de arqueros
        const idleAnimations = [
            'idle', 'stand', 'wait', 'ready', 'goalkeeper_idle', 
            'keeper_stand', 'neutral', 'default'
        ];
        for (const animName of idleAnimations) {
            if (this.playAnimation(animName, { loop: true })) {
                return true;
            }
        }
        return false;
    }

    playDiveAnimation(direction = 'center') {
        // Buscar animaciones de zambullida seg√∫n direcci√≥n
        const diveAnimations = [
            `dive_${direction}`, `dive${direction}`, `save_${direction}`,
            'dive', 'save', 'catch', 'block', 'jump', 'goalkeeper_dive',
            'keeper_save', 'reaction'
        ];
        for (const animName of diveAnimations) {
            if (this.playAnimation(animName, { loop: false, timeScale: 1.2 })) {
                return true;
            }
        }
        return false;
    }

    playReactionAnimation() {
        // Buscar animaciones de reacci√≥n y preparaci√≥n
        const reactionAnimations = [
            'react', 'alert', 'focus', 'prepare', 'goalkeeper_react',
            'keeper_ready', 'anticipate', 'tense'
        ];
        for (const animName of reactionAnimations) {
            if (this.playAnimation(animName, { loop: false })) {
                return true;
            }
        }
        return false;
    }

    reset() {
        console.log('üîÑ Reseteando arquero...');
        
        gsap.killTweensOf(this.model.position);
        gsap.killTweensOf(this.model.rotation);
        this.model.position.copy(this.initialPos);
        this.model.rotation.set(0, 0, 0);
        this.state = 'IDLE';
        this.reactionTime = 0.2 + Math.random() * 0.15;
        
        // Generar nuevas habilidades para variabilidad
        this.skills = {
            reflexes: 0.6 + Math.random() * 0.3,
            positioning: 0.5 + Math.random() * 0.4,
            reach: 0.7 + Math.random() * 0.2
        };
        
        console.log(`üß§ Nuevo arquero - R:${(this.skills.reflexes*100).toFixed(0)} P:${(this.skills.positioning*100).toFixed(0)} A:${(this.skills.reach*100).toFixed(0)}`);
        
        // Iniciar inmediatamente el movimiento en l√≠nea
        this.startIdleAnimation();
    }
    
    normalizeRotation() {
        // Funci√≥n para asegurar que la rotaci√≥n vuelva a neutral
        gsap.set(this.model.rotation, { x: 0, y: 0, z: 0 });
        
        // Si hay animaciones activas, cancelarlas
        gsap.killTweensOf(this.model.rotation);
    }
    
    startIdleAnimation() {
        // Intentar usar animaci√≥n idle del modelo ElShenawy primero
        if (!this.playIdleAnimation()) {
            // Si no hay animaciones, usar movimiento por c√≥digo
            this.startGoalLineMovement();
        }
    }
    
    startGoalLineMovement() {
        console.log('ü•Ö Iniciando movimiento en l√≠nea de arco...');
        
        // Movimiento lateral constante en la l√≠nea del arco
        const movePattern = Math.random(); // Patr√≥n aleatorio de movimiento
        
        if (movePattern < 0.33) {
            // Patr√≥n 1: ULTRA R√ÅPIDO Y EXTREMO
            this.createMovementSequence([
                { x: -3.5, duration: 0.8 },  // M√ÅS extremo y M√ÅS r√°pido
                { x: 0, duration: 0.5 },     // M√ÅS r√°pido
                { x: 3.5, duration: 0.8 },   // M√ÅS extremo y M√ÅS r√°pido
                { x: 0, duration: 0.5 },     // M√ÅS r√°pido
                { x: -1.5, duration: 0.4 },  // Movimiento extra
                { x: 1.5, duration: 0.4 }    // Movimiento extra
            ]);
        } else if (movePattern < 0.66) {
            // Patr√≥n 2: ULTRA R√ÅPIDO Y EXTREMO (opuesto)
            this.createMovementSequence([
                { x: 3.5, duration: 0.8 },   // M√ÅS extremo y M√ÅS r√°pido
                { x: 0, duration: 0.5 },     // M√ÅS r√°pido
                { x: -3.5, duration: 0.8 },  // M√ÅS extremo y M√ÅS r√°pido
                { x: 0, duration: 0.5 },     // M√ÅS r√°pido
                { x: 1.5, duration: 0.4 },   // Movimiento extra
                { x: -1.5, duration: 0.4 }   // Movimiento extra
            ]);
        } else {
            // Patr√≥n 3: MOVIMIENTO CA√ìTICO S√öPER R√ÅPIDO
            this.createMovementSequence([
                { x: -2.5, duration: 0.4 },  // S√öPER r√°pido
                { x: 2.5, duration: 0.4 },   // S√öPER r√°pido
                { x: -3.0, duration: 0.5 },  // M√ÅS extremo
                { x: 3.0, duration: 0.5 },   // M√ÅS extremo
                { x: -1.0, duration: 0.3 },  // ULTRA r√°pido
                { x: 1.0, duration: 0.3 },   // ULTRA r√°pido
                { x: 0, duration: 0.3 }      // Centro r√°pido
            ]);
        }
        
        // Variaciones en Y S√öPER PRONUNCIADAS y M√ÅS R√ÅPIDAS
        gsap.to(this.model.position, {
            y: this.initialPos.y + 0.3, // S√öPER visible
            duration: 0.5 + Math.random() * 0.3, // M√ÅS R√ÅPIDO
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
        
        // Rotaci√≥n corporal S√öPER VISIBLE y M√ÅS R√ÅPIDA
        gsap.to(this.model.rotation, {
            y: 0.5, // M√ÅS pronunciado
            duration: 1.5, // M√ÅS R√ÅPIDO
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
    }
    
    createMovementSequence(positions) {
        const timeline = gsap.timeline({ repeat: -1 });
        
        positions.forEach((pos, index) => {
            timeline.to(this.model.position, {
                x: this.initialPos.x + pos.x,
                duration: pos.duration,
                ease: this.state === 'AIMING_ACTIVE' ? 'sine.inOut' : (index % 2 === 0 ? 'power1.inOut' : 'power2.inOut')
            });
            
            // Durante apuntado: pausas m√°s cortas y predecibles
            if (this.state === 'AIMING_ACTIVE') {
                timeline.to({}, { duration: 0.3 }); // Pausa fija
            } else {
                // Comportamiento normal: pausas aleatorias
                if (Math.random() < 0.3) {
                    timeline.to({}, { duration: 0.2 + Math.random() * 0.3 });
                }
            }
        });
        
        const movementType = this.state === 'AIMING_ACTIVE' ? 'LENTO (apuntado)' : 'NORMAL (pre-penal)';
        console.log(`üéØ Secuencia ${movementType} de ${positions.length} movimientos creada`);
    }

    /**
     * @param {THREE.Vector3} targetPoint - Punto donde se predice que llegar√° la pelota
     */
    reactToShot(targetPoint) {
        this.state = 'REACTING';
        
        // AHORA S√ç DETENER el movimiento - solo cuando se patee
        this.stopGoalLineMovement();
        
        console.log(`ü•Ö ¬°PENAL PATEADO! Arquero reaccionando desde posici√≥n: ${this.model.position.x.toFixed(2)}`);
        console.log(`üõë Movimiento en l√≠nea detenido - Habilidades: R${(this.skills.reflexes*100).toFixed(0)} P${(this.skills.positioning*100).toFixed(0)} A${(this.skills.reach*100).toFixed(0)}`);
        
        // Intentar animaci√≥n de reacci√≥n primero
        if (!this.playReactionAnimation()) {
            // Si no hay animaciones, usar movimiento por c√≥digo
            this.showTension();
        }
        
        // Luego decidir la acci√≥n seg√∫n habilidades
        setTimeout(() => this.makeRealisticDecision(targetPoint), this.reactionTime * 1000);
    }
    
    // Nuevo m√©todo: continuar movimiento durante el apuntado
    continueDuringAiming() {
        if (this.state === 'IDLE') {
            console.log('üéØ Continuando movimiento durante apuntado...');
            // El movimiento ya est√° activo, no hacer nada extra
            // Solo cambiar el estado para tracking
            this.state = 'AIMING_ACTIVE';
        }
    }
    
    // Nuevo m√©todo: transici√≥n suave cuando se empieza a apuntar
    onAimingStart() {
        console.log('üéØ Jugador empez√≥ a apuntar - Cambiando a movimiento de apuntado');
        this.state = 'AIMING_ACTIVE';
        
        // Cambiar a un patr√≥n de movimiento m√°s lento y predecible durante el apuntado
        this.startAimingMovement();
    }
    
    startAimingMovement() {
        // Detener el movimiento r√°pido anterior
        gsap.killTweensOf(this.model.position);
        gsap.killTweensOf(this.model.rotation);
        
        console.log('üöÄ MOVIMIENTO EXTREMO Y R√ÅPIDO durante apuntado - M√ÅS RANGO!');
        
        // Movimiento S√öPER EXTREMO y M√ÅS R√ÅPIDO
        const ultraExtremeSequence = [
            { x: -4.5, duration: 1.5 },   // EXTREMO EXTREMO IZQUIERDO (m√°s r√°pido)
            { x: -2.0, duration: 0.8 },   // Paso intermedio (m√°s r√°pido)
            { x: 0, duration: 0.6 },      // Centro (m√°s r√°pido)
            { x: 2.0, duration: 0.8 },    // Paso intermedio (m√°s r√°pido)
            { x: 4.5, duration: 1.5 },    // EXTREMO EXTREMO DERECHO (m√°s r√°pido)
            { x: 2.5, duration: 0.8 },    // Vuelta intermedia (m√°s r√°pido)
            { x: 0, duration: 0.6 },      // Centro otra vez (m√°s r√°pido)
            { x: -2.5, duration: 0.8 },   // Preparar siguiente ciclo (m√°s r√°pido)
            { x: -1.0, duration: 0.6 },   // Extra movimiento
            { x: 1.0, duration: 0.6 },    // Extra movimiento
            { x: 3.0, duration: 1.0 },    // Extra extremo
            { x: -3.0, duration: 1.0 }    // Extra extremo
        ];
        
        this.createMovementSequence(ultraExtremeSequence);
        
        // Movimiento vertical M√ÅS R√ÅPIDO y M√ÅS PRONUNCIADO
        gsap.to(this.model.position, {
            y: this.initialPos.y + 0.25, // A√öN m√°s visible
            duration: 1.0, // M√ÅS R√ÅPIDO
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
        
        // Rotaci√≥n corporal M√ÅS R√ÅPIDA y M√ÅS VISIBLE
        gsap.to(this.model.rotation, {
            y: 0.4, // M√ÅS pronunciado
            duration: 2.0, // M√ÅS R√ÅPIDO
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
        
        console.log('üéØ Rango de movimiento: -4.5 a +4.5 unidades (ULTRA EXTREMO)');
        console.log('‚ö° Velocidad aumentada: 0.6-1.5s por movimiento');
    }
    
    stopGoalLineMovement() {
        // Detener TODAS las animaciones de movimiento previas
        gsap.killTweensOf(this.model.position);
        gsap.killTweensOf(this.model.rotation);
        
        // Detener animaciones del modelo si existen
        this.stopAnimation();
        
        console.log('üö´ Movimiento en l√≠nea de arco detenido');
        
        // Peque√±a pausa de "congelamiento" realista (0.1s)
        gsap.set(this.model.position, {
            x: this.model.position.x, // Mantener posici√≥n actual
            y: this.initialPos.y,     // Volver a altura normal
            z: this.initialPos.z      // Mantener profundidad
        });
        
        gsap.set(this.model.rotation, {
            x: 0,
            y: 0, 
            z: 0  // Resetear rotaci√≥n para evitar la "T"
        });
    }
    
    showTension() {
        // Reacci√≥n de tensi√≥n m√°s org√°nica
        const tensionTimeline = gsap.timeline();
        
        // Momento de shock - congelarse brevemente
        tensionTimeline.to(this.model.position, {
            y: this.initialPos.y + 0.02,
            duration: 0.05,
            ease: 'power2.out'
        });
        
        // Reacci√≥n corporal - agacharse y prepararse
        tensionTimeline.to(this.model.position, {
            y: this.initialPos.y - 0.08,
            duration: 0.15,
            ease: 'back.out(1.7)'
        });
        
        // Tensi√≥n muscular (rotaciones sutiles)
        tensionTimeline.to(this.model.rotation, {
            x: -0.08,
            z: (Math.random() - 0.5) * 0.05, // Variaci√≥n aleatoria
            duration: 0.1,
            ease: 'power2.out'
        }, 0.05);
        
        // Micro-temblor de nervios
        tensionTimeline.to(this.model.position, {
            x: this.initialPos.x + (Math.random() - 0.5) * 0.02,
            duration: 0.05,
            ease: 'sine.inOut',
            yoyo: true,
            repeat: 3
        }, 0.1);
    }
    
    makeRealisticDecision(targetPoint) {
        if (!targetPoint) {
            this.stayReady();
            return;
        }
        
        const distanceFromCenter = Math.abs(targetPoint.x);
        const shotHeight = targetPoint.y;
        const shotSpeed = Math.sqrt(targetPoint.x * targetPoint.x + targetPoint.y * targetPoint.y);
        
        // Factores humanos realistas
        const canReach = distanceFromCenter <= (this.skills.reach * 2.5);
        const hasTime = shotSpeed < (3.0 + this.skills.reflexes * 2.0);
        const rightPosition = this.skills.positioning > 0.6;
        
        console.log(`üß† Evaluando: Dist=${distanceFromCenter.toFixed(1)} Alt=${shotHeight.toFixed(1)} Alcance=${canReach} Tiempo=${hasTime}`);
        
        // Decisiones m√°s humanas con intentos de usar animaciones
        if (distanceFromCenter < 0.8 && shotHeight < 1.0) {
            // Tiro muy central - quedarse firme
            this.stayReady();
            console.log('üí™ Decisi√≥n: Quedarse firme');
            
        } else if (distanceFromCenter < 1.5 && hasTime && rightPosition) {
            // Tiro alcanzable - paso lateral
            this.takeSmartStep(targetPoint);
            console.log('üëü Decisi√≥n: Paso lateral');
            
        } else if (canReach && hasTime && this.skills.reflexes > 0.7) {
            // Arquero h√°bil con tiempo - zambullida
            this.diveSmart(targetPoint);
            console.log('ü§∏‚Äç‚ôÇÔ∏è Decisi√≥n: Zambullida');
            
        } else if (Math.random() < 0.3) {
            // 30% de probabilidad de intentar lo imposible (coraz√≥n)
            this.desperateAttempt(targetPoint);
            console.log('üíî Decisi√≥n: Intento desesperado');
            
        } else {
            // Resignarse - no puede hacer nada
            this.watchItGo(targetPoint);
            console.log('üòî Decisi√≥n: Solo mirar');
        }
        
        // IMPORTANTE: Programar recuperaci√≥n autom√°tica despu√©s de cualquier acci√≥n
        this.scheduleRecovery();
    }
    
    scheduleRecovery() {
        // Despu√©s de 2-3 segundos, volver autom√°ticamente a posici√≥n neutral
        setTimeout(() => {
            if (this.state !== 'IDLE') {
                console.log('üîÑ Recuperando posici√≥n neutral...');
                this.returnToNeutral();
            }
        }, 2000 + Math.random() * 1000);
    }
    
    returnToNeutral() {
        this.state = 'RECOVERING';
        gsap.killTweensOf(this.model.position);
        gsap.killTweensOf(this.model.rotation);
        
        // Detener cualquier animaci√≥n activa
        this.stopAnimation();
        
        // Animaci√≥n suave de vuelta a la posici√≥n inicial
        gsap.to(this.model.position, {
            x: this.initialPos.x,
            y: this.initialPos.y,
            z: this.initialPos.z,
            duration: 1.0,
            ease: 'power2.inOut',
            onComplete: () => {
                // Cuando termine la recuperaci√≥n, volver a idle
                this.state = 'IDLE';
                this.startIdleAnimation();
            }
        });
        
        // CLAVE: Resetear TODAS las rotaciones gradualmente
        gsap.to(this.model.rotation, {
            x: 0,
            y: 0,
            z: 0,
            duration: 1.0,
            ease: 'power2.inOut'
        });
    }
    
    stayReady() {
        this.state = 'READY';
        console.log('üí™ Arquero se queda en posici√≥n - Sin rotaciones complicadas');
        
        // Intentar animaci√≥n primero
        if (!this.playAnimation('ready') && !this.playAnimation('idle')) {
            // Si no hay animaciones, usar movimiento por c√≥digo
            gsap.to(this.model.position, {
                y: this.initialPos.y - 0.1, // Agacharse ligeramente
                duration: 0.3,
                ease: 'power2.out'
            });
        }
        
        // Mantener rotaci√≥n neutral
        gsap.set(this.model.rotation, { x: 0, y: 0, z: 0 });
    }
    
    takeSmartStep(targetPoint) {
        this.state = 'STEPPING';
        const direction = targetPoint.x > 0 ? 'right' : 'left';
        const stepSize = Math.min(1.0, Math.abs(targetPoint.x) * 0.7) * this.skills.positioning;
        const directionMultiplier = targetPoint.x > 0 ? 1 : -1;
        
        console.log(`üëü Paso lateral hacia ${direction} - Distancia: ${stepSize.toFixed(2)}`);
        
        // Intentar animaci√≥n de paso lateral primero
        if (!this.playAnimation(`step_${direction}`) && !this.playAnimation('step')) {
            // Si no hay animaciones, usar movimiento por c√≥digo
            gsap.to(this.model.position, {
                x: this.model.position.x + stepSize * directionMultiplier,
                y: this.initialPos.y - 0.05,
                duration: 0.3,
                ease: 'power2.out'
            });
        }
        
        // SIN rotaciones - mantener neutral
        gsap.set(this.model.rotation, { x: 0, y: 0, z: 0 });
    }
    
    diveSmart(targetPoint) {
        this.state = 'DIVING';
        const reachFactor = this.skills.reach;
        const direction = targetPoint.x > 0 ? 'right' : 'left';
        const directionMultiplier = targetPoint.x > 0 ? 1 : -1;
        
        const diveX = Math.min(this.goalLimits.maxX, Math.abs(targetPoint.x) * reachFactor) * directionMultiplier;
        const diveY = Math.min(this.goalLimits.maxY, Math.max(0.2, targetPoint.y * 0.8));
        
        console.log(`ü§∏‚Äç‚ôÇÔ∏è Zambullida hacia ${direction} - X:${diveX.toFixed(2)} Y:${diveY.toFixed(2)}`);
        
        // Intentar animaci√≥n de zambullida primero
        if (!this.playDiveAnimation(direction) && !this.playAnimation('dive')) {
            // Si no hay animaciones, usar movimiento por c√≥digo
            gsap.to(this.model.position, {
                x: this.model.position.x + diveX,
                y: diveY,
                duration: 0.4,
                ease: 'power2.out'
            });
        }
        
        // SIN rotaciones complicadas - solo mantener neutral
        gsap.set(this.model.rotation, { x: 0, y: 0, z: 0 });
    }
    
    desperateAttempt(targetPoint) {
        this.state = 'DESPERATE';
        const direction = targetPoint.x > 0 ? 'right' : 'left';
        const directionMultiplier = targetPoint.x > 0 ? 1 : -1;
        
        console.log(`üíî Intento desesperado hacia ${direction}`);
        
        // Intentar animaci√≥n desesperada primero
        if (!this.playAnimation('desperate') && !this.playDiveAnimation(direction)) {
            // Si no hay animaciones, usar movimiento por c√≥digo
            gsap.to(this.model.position, {
                x: this.model.position.x + directionMultiplier * 1.5,
                y: this.initialPos.y + 0.3,
                duration: 0.5,
                ease: 'power2.out'
            });
        }
        
        // SIN rotaciones - mantener neutral
        gsap.set(this.model.rotation, { x: 0, y: 0, z: 0 });
    }
    
    watchItGo(targetPoint) {
        this.state = 'WATCHING';
        const direction = targetPoint.x > 0 ? 'right' : 'left';
        const directionMultiplier = targetPoint.x > 0 ? 1 : -1;
        
        console.log(`üëÄ Solo mirando hacia ${direction}`);
        
        // Intentar animaci√≥n de observaci√≥n primero
        if (!this.playAnimation('watch') && !this.playAnimation('disappointed')) {
            // Si no hay animaciones, usar movimiento por c√≥digo
            gsap.to(this.model.position, {
                x: this.model.position.x + directionMultiplier * 0.3,
                y: this.initialPos.y - 0.05, // Ligero agachamiento
                duration: 0.4,
                ease: 'sine.out'
            });
        }
        
        // SIN rotaciones - mantener neutral
        gsap.set(this.model.rotation, { x: 0, y: 0, z: 0 });
    }
    
    checkSave(ballPosition) {
        // Solo puede atajar si est√° en una acci√≥n activa
        if (this.state === 'IDLE' || this.state === 'WATCHING') return false;
        
        const keeperPos = this.model.position;
        const distance = new THREE.Vector3(
            ballPosition.x - keeperPos.x,
            ballPosition.y - keeperPos.y,
            0 // Ignorar profundidad para c√°lculo m√°s realista
        ).length();
        
        // C√°lculo de atajada basado en habilidades reales
        let saveChance = 0;
        
        // Radio efectivo basado en el estado y habilidades
        let effectiveReach;
        switch(this.state) {
            case 'READY':
                effectiveReach = 0.8 * this.skills.reach;
                saveChance = 0.7; // Alta probabilidad para tiros centrales
                break;
            case 'STEPPING':
                effectiveReach = 1.3 * this.skills.reach;
                saveChance = 0.5 * this.skills.positioning;
                break;
            case 'DIVING':
                effectiveReach = 1.8 * this.skills.reach;
                saveChance = 0.4 * this.skills.reflexes;
                break;
            case 'DESPERATE':
                effectiveReach = 2.0 * this.skills.reach;
                saveChance = 0.15; // Baja probabilidad en intentos desesperados
                break;
            default:
                effectiveReach = 1.0;
                saveChance = 0.3;
        }
        
        // Solo puede atajar si est√° dentro del alcance
        if (distance > effectiveReach) {
            return false;
        }
        
        // Modificadores realistas
        if (ballPosition.y > 1.8) saveChance *= 0.7; // M√°s dif√≠cil arriba
        if (ballPosition.y < 0.5) saveChance *= 1.2; // M√°s f√°cil abajo
        if (Math.abs(ballPosition.x) > 1.5) saveChance *= 0.8; // M√°s dif√≠cil en extremos
        
        // Factor de suerte/concentraci√≥n
        const concentration = 0.8 + Math.random() * 0.4; // 0.8-1.2
        saveChance *= concentration;
        
        // Limitar probabilidad
        saveChance = Math.max(0, Math.min(0.85, saveChance));
        
        const isSaved = Math.random() < saveChance;
        
        console.log(`ü•Ö ${isSaved ? 'ATAJADA' : 'GOL'} - Dist: ${distance.toFixed(1)}m, Estado: ${this.state}, Prob: ${(saveChance*100).toFixed(0)}%`);
        
        return isSaved;
    }
}
</file>

<file path="src/experience/States.js">
import * as THREE from 'three';
import gsap from 'gsap';

const PENALTY_SPOT = new THREE.Vector3(0, 0, 0);
const PLAYER_AREA_RADIUS = 9; 
const GRAVITY = 9.8;

class State {
    constructor(name, manager) {
        this.name = name;
        this.manager = manager;
    }
    enter(params) {}
    update(deltaTime) {}
    exit() {}
}

class IntroState extends State {
    enter() { this.manager.ui.showIntro(true); }
    exit() { this.manager.ui.showIntro(false); }
}

class PrePenalState extends State {
    enter() {
        console.log('Entering PRE_PENAL state');
        this.manager.audio.fade('heartbeat', 0.5, 2);
        
        // Auto-mover el jugador hacia la pelota
        this.autoMoveTowardsBall();
    }
    
    autoMoveTowardsBall() {
        // Calcular posici√≥n cerca de la pelota
        const ballPosition = this.manager.ball.position;
        const targetPosition = new THREE.Vector3(
            ballPosition.x,
            this.manager.player.position.y, // Mantener altura
            ballPosition.z + 2.5 // 2.5 unidades detr√°s de la pelota
        );
        
        console.log('üöÄ Auto-moving player to ball...');
        
        // Mover suavemente hacia la pelota
        gsap.to(this.manager.player.position, {
            x: targetPosition.x,
            z: targetPosition.z,
            duration: 2,
            ease: 'power2.out',
            onComplete: () => {
                // Cuando llegue cerca de la pelota, cambiar a AIMING
                this.manager.stateMachine.changeState('AIMING');
            }
        });
    }
    
    update(deltaTime) {
        // El estado PRE_PENAL ahora solo espera la animaci√≥n autom√°tica
        // No necesita l√≥gica de movimiento manual
    }
    
    exit() { 
        // Detener cualquier animaci√≥n en curso
        gsap.killTweensOf(this.manager.player.position);
    }
}

class AimingState extends State {
    enter() {
        console.log('üéØ Entrando en estado AIMING - Arquero sigue movi√©ndose');
        // Notificar al arquero que empiece la fase de apuntado
        if (this.manager.goalkeeperAI) {
            this.manager.goalkeeperAI.onAimingStart();
        }
    }
    
    update(deltaTime) {
        const profileSpeed = 1.0;
        if (this.manager.input.keys.a) this.manager.player.position.x -= profileSpeed * deltaTime;
        if (this.manager.input.keys.d) this.manager.player.position.x += profileSpeed * deltaTime;
        
        this.manager.player.position.x = THREE.MathUtils.clamp(this.manager.player.position.x, -1.5, 1.5);
        this.manager.ui.updatePowerBar(this.manager.input.power);
    }
}

class KickState extends State {
    constructor(name, manager) {
        super(name, manager);
        this.hasCheckedOutcome = false;
    }

    enter(params) {
        this.hasCheckedOutcome = false;
        
        // ¬°MONTIEL CUANDO SE PATEE!
        console.log('üéôÔ∏è About to play Montiel...');
        this.manager.audio.playMontiel();
        
        this.manager.ui.showHUD(false);
        this.manager.input.power = 0; 

        const pressure = this.manager.ui.getPressure();
        const shotData = this.manager.shotModel.calculateTrajectory(
            this.manager.camera.rotation, params.power, pressure
        );
        
        this.manager.ball.userData.velocity = shotData.initialVelocity;
        this.manager.ball.userData.targetPoint = shotData.targetPoint;

        this.manager.toBallFollowView(this.manager.ball);
        this.manager.goalkeeperAI.reactToShot(shotData.targetPoint);
        
        gsap.to(this.manager.camera.position, { z: this.manager.camera.position.z - 0.2, yoyo: true, repeat: 1, duration: 0.1 });
    }

    update(deltaTime) {
        if (!this.manager.ball.userData.velocity) return;

        this.manager.ball.position.add(this.manager.ball.userData.velocity.clone().multiplyScalar(deltaTime));
        this.manager.ball.userData.velocity.y -= GRAVITY * deltaTime;
        
        // Evitar que la pelota traspase el suelo
        if (this.manager.ball.position.y < 0.1) {
            this.manager.ball.position.y = 0.1;
            this.manager.ball.userData.velocity.y = 0; // Detener movimiento vertical
        }
        
        const GOAL_LINE_Z = -15; 
        if (this.manager.ball.position.z <= GOAL_LINE_Z && !this.hasCheckedOutcome) {
            this.checkOutcome();
        }
    }

    checkOutcome() {
        this.hasCheckedOutcome = true;
        const ballPos = this.manager.ball.position;

        // --- DIMENSIONES CORREGIDAS: Ajustadas al modelo 3D escalado (3x) ---
        // Aumentando considerablemente las dimensiones para que coincidan con el modelo visual
        const goalWidth = 20.0;  // Ancho de la porter√≠a (a√∫n m√°s generoso)
        const goalHeight = 8.0;  // Alto de la porter√≠a (a√∫n m√°s generoso)

        if (this.manager.goalkeeperAI.checkSave(ballPos)) {
            this.manager.stateMachine.changeState('OUTCOME', { result: 'save' });
        
        } else if (Math.abs(ballPos.x) > goalWidth / 2 || ballPos.y > goalHeight || ballPos.y < 0) {
            this.manager.stateMachine.changeState('OUTCOME', { result: 'post' });

        } else {
            this.manager.stateMachine.changeState('OUTCOME', { result: 'goal' });
        }
    }
    
    exit() {
        if(this.manager.ball.userData.velocity) this.manager.ball.userData.velocity.set(0,0,0);
    }
}

class OutcomeState extends State {
    enter(params) {
        switch(params.result) {
            case 'goal':
                // this.manager.audio.play('goal'); // Comentado - archivo no existe
                this.manager.toStadiumView();
                setTimeout(() => this.manager.stateMachine.changeState('EPILOGUE', { title: "¬°GOOOOL!" }), 2000);
                break;
            case 'save':
                // this.manager.audio.play('fail'); // Comentado - archivo no existe
                gsap.to(this.manager.ball.position, { 
                    x: this.manager.ball.position.x * 1.1, y: this.manager.ball.position.y * 0.5,
                    z: this.manager.ball.position.z - 1, duration: 1
                });
                setTimeout(() => this.manager.stateMachine.changeState('EPILOGUE', { title: "¬°Atajada!" }), 2000);
                break;
            case 'post':
                // this.manager.audio.play('fail'); // Comentado - archivo no existe
                gsap.to(this.manager.ball.position, { 
                    x: this.manager.ball.position.x * 1.1, y: this.manager.ball.position.y * 0.5,
                    z: this.manager.ball.position.z - 1, duration: 1
                });
                setTimeout(() => this.manager.stateMachine.changeState('EPILOGUE', { title: "¬°Fallado!" }), 2000);
                break;
        }
    }
}

class EpilogueState extends State {
    enter(params) {
        this.manager.ui.showEpilogue(true, params.title);
        this.manager.controls.unlock();
    }
    exit() { this.manager.ui.showEpilogue(false); }
}


export default class StateMachine {
    constructor(manager) {
        this.manager = manager;
        this.states = {
            'INTRO': new IntroState('INTRO', manager),
            'PRE_PENAL': new PrePenalState('PRE_PENAL', manager),
            'AIMING': new AimingState('AIMING', manager),
            'KICK': new KickState('KICK', manager),
            'OUTCOME': new OutcomeState('OUTCOME', manager),
            'EPILOGUE': new EpilogueState('EPILOGUE', manager),
        };
        this.currentState = null;
    }

    changeState(name, params) {
        if (this.currentState) this.currentState.exit();
        this.currentState = this.states[name];
        this.currentState.enter(params);
    }

    update(deltaTime) {
        if (this.currentState) this.currentState.update(deltaTime);
    }
}
</file>

<file path="src/experience/UI.js">
import EventEmitter from 'eventemitter3';

export default class UIManager extends EventEmitter {
    constructor() {
        super();
        this.introOverlay = document.getElementById('intro-overlay');
        this.epilogueOverlay = document.getElementById('epilogue-overlay');
        this.hud = document.getElementById('hud');
        this.powerBar = document.getElementById('power-bar');
        
        document.getElementById('start-button').addEventListener('click', (e) => {
            console.log('üéÆ START BUTTON CLICKED!');
            console.log('Event target:', e.target);
            console.log('Button element:', document.getElementById('start-button'));
            this.emit('start');
            e.target.blur();
        });
        
        document.getElementById('retry-button').addEventListener('click', (e) => {
            this.emit('retry');
            e.target.blur();
        });
        
        // NO crear bot√≥n de toggle - control con pie siempre activo
    }

    showIntro(visible) {
        this.introOverlay.classList.toggle('hidden', !visible);
        this.introOverlay.classList.toggle('active', visible);
    }
    
    showHUD(visible) {
        this.hud.classList.toggle('hidden', !visible);
    }

    showEpilogue(visible, title = "") {
        document.getElementById('epilogue-title').innerText = title;
        this.epilogueOverlay.classList.toggle('hidden', !visible);
        this.epilogueOverlay.classList.toggle('active', visible);
    }

    updatePowerBar(power) {
        this.powerBar.style.width = `${power * 100}%`;
    }

    getPressure() {
        return 0.3; // Valor fijo de presi√≥n moderada
    }
    
    reset() {
        this.showHUD(true);
        this.showEpilogue(false);
    }
}
</file>

<file path="src/experience/SceneManager.js">
import * as THREE from 'three';
import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
import gsap from 'gsap';

import Assets from './Assets';
import StateMachine from './States';
import InputManager from './Input';
import AudioManager from './Audio';
import UIManager from './UI';
import GoalkeeperAI from './GoalkeeperAI';
import ShotModel from './ShotModel';
import KickGestureManager from './KickGestureManager';
import Stadium from './Stadium';

export default class SceneManager {
    constructor(canvas) {
        this.canvas = canvas;
        this.sizes = { width: window.innerWidth, height: window.innerHeight };
        
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, this.sizes.width / this.sizes.height, 0.1, 100);
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
        this.renderer.setSize(this.sizes.width, this.sizes.height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;

        this.assets = new Assets();
        this.input = new InputManager();
        this.ui = new UIManager();
        this.audio = new AudioManager();
        this.gesture = new KickGestureManager();
        this.stateMachine = new StateMachine(this);
        this.shotModel = new ShotModel();

        this.player = new THREE.Group();
        this.ball = null;
        this.goalkeeper = null;
        this.goal = null;
        this.cameraLookTarget = new THREE.Vector3(); 

        this.controls = new PointerLockControls(this.camera, document.body);
        this.goalkeeperAI = null;
        this.stadium = null;
        
        this.aimMarker = null;
        this.aimMarkerVisible = false;
        
        this.gestureControlActive = false;

        this.init();
    }

    init() {
        console.log('üöÄ SceneManager init() called');
        this.setupScene();
        this.bindEventListeners();
        
        console.log('üéµ Initializing audio immediately...');
        this.audio.init(this.camera);
        
        this.initGestureControl();
        
        this.assets.on('loaded', () => {
            this.buildWorld();
            console.log('‚úÖ Assets loaded, checking montiel audio...');
            setTimeout(() => {
                this.audio.ensureMontielReady();
            }, 500);
            this.stateMachine.changeState('INTRO');
        });
    }

    async initGestureControl() {
        console.log('üñêÔ∏è Initializing gesture control...');
        
        this.gesture.on('ready', () => {
            console.log('‚úÖ Gesture control ready!');
        });
        
        this.gesture.on('error', (error) => {
            console.error('‚ùå Gesture control error:', error);
            alert('Error al inicializar control por gestos. Verifica que tu c√°mara est√© conectada.');
        });
    }

    setupScene() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffffff, 1.2, 100, Math.PI * 0.2, 0.5);
        spotLight.position.set(0, 15, 0); 
        spotLight.castShadow = true;
        this.scene.add(spotLight);

        const stadiumLights = [
            { pos: [-20, 12, -10], color: 0xffffee, intensity: 0.8 },
            { pos: [20, 12, -10], color: 0xffffee, intensity: 0.8 },
            { pos: [-20, 12, 10], color: 0xffffee, intensity: 0.8 },
            { pos: [20, 12, 10], color: 0xffffee, intensity: 0.8 },
            { pos: [0, 20, -20], color: 0xffffff, intensity: 1.0 },
            { pos: [0, 8, 15], color: 0xffffff, intensity: 0.6 }
        ];

        stadiumLights.forEach(lightConfig => {
            const light = new THREE.DirectionalLight(lightConfig.color, lightConfig.intensity);
            light.position.set(lightConfig.pos[0], lightConfig.pos[1], lightConfig.pos[2]);
            light.target.position.set(0, 0, -7);
            light.castShadow = false;
            this.scene.add(light);
            this.scene.add(light.target);
        });

        const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x2F4F4F, 0.4);
        this.scene.add(hemisphereLight);

        const topLight = new THREE.DirectionalLight(0xffffff, 1.0);
        topLight.position.set(0, 30, -10);
        topLight.target.position.set(0, 0, -7);
        topLight.castShadow = false;
        this.scene.add(topLight);
        this.scene.add(topLight.target);

        const fillLights = [
            new THREE.DirectionalLight(0xffffee, 0.3),
            new THREE.DirectionalLight(0xffffee, 0.3),
            new THREE.DirectionalLight(0xffffee, 0.3),
            new THREE.DirectionalLight(0xffffee, 0.3)
        ];

        fillLights[0].position.set(-15, 20, -5);
        fillLights[1].position.set(15, 20, -5);
        fillLights[2].position.set(-15, 20, 5);
        fillLights[3].position.set(15, 20, 5);

        fillLights.forEach(light => {
            light.target.position.set(0, 0, -7);
            this.scene.add(light);
            this.scene.add(light.target);
        });

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({ 
                color: 0x2d6a2b,
                roughness: 0.8,
                metalness: 0.1
            }) 
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        this.scene.add(ground);

        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const spotGeometry = new THREE.CircleGeometry(0.1, 32);
        const penaltySpot = new THREE.Mesh(spotGeometry, lineMaterial);
        penaltySpot.rotation.x = -Math.PI / 2;
        penaltySpot.position.y = 0.01; 
        this.scene.add(penaltySpot);

        this.stadium = new Stadium(this.scene);
        this.stadium.createWorldCupFinalAtmosphere();
        
        setTimeout(() => {
            this.stadium.optimizeForPerformance();
        }, 2000);
        
        console.log('üèüÔ∏è Estadio creado con ambiente de final del mundo');
    }
    
    buildWorld() {
        console.log('üéØ Construyendo elementos principales del juego con alta calidad...');
        
        const goalModel = this.assets.get('arco');
        this.goal = goalModel.scene;
        this.goal.position.set(0, 0, -15);
        this.goal.scale.set(3, 3, 3);
        this.goal.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });
        this.scene.add(this.goal);

        const ballModel = this.assets.get('pelota');
        
        if (!ballModel) {
            console.error('‚ùå ERROR: Modelo de pelota no encontrado');
            const fallbackBall = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 32, 32),
                new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 0.5,
                    metalness: 0.1
                })
            );
            this.ball = fallbackBall;
        } else {
            this.ball = ballModel.scene;
        }
        
        this.ball.scale.set(0.1, 0.1, 0.1);
        this.ball.position.set(0, 0.1, 0);
        this.ball.userData.velocity = new THREE.Vector3(0, 0, 0);
        
        this.ball.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.needsUpdate = true;
                }
            }
        });
        
        this.scene.add(this.ball);
        console.log('‚öΩ Pelota a√±adida a la escena');
        
        const keeperModel = this.assets.get('arquero');
        this.goalkeeper = keeperModel.scene;
        this.goalkeeper.position.set(0, 0, -14.8);
        this.goalkeeper.scale.set(1.5, 1.5, 1.5);
        
        this.goalkeeperAnimations = keeperModel.animations || [];
        this.goalkeeperMixer = null;
        
        if (this.goalkeeperAnimations.length > 0) {
            console.log(`üé≠ Arquero ElShenawy tiene ${this.goalkeeperAnimations.length} animaciones:`, 
                this.goalkeeperAnimations.map(anim => anim.name));
            
            this.goalkeeperMixer = new THREE.AnimationMixer(this.goalkeeper);
            
            this.goalkeeperClips = {};
            this.goalkeeperAnimations.forEach(animation => {
                const action = this.goalkeeperMixer.clipAction(animation);
                this.goalkeeperClips[animation.name] = action;
                console.log(`‚úÖ Animaci√≥n preparada: ${animation.name} (duraci√≥n: ${animation.duration.toFixed(2)}s)`);
            });
        } else {
            console.log('‚ÑπÔ∏è El arquero ElShenawy no tiene animaciones incluidas');
        }
        
        this.goalkeeper.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    child.material.needsUpdate = true;
                }
            }
        });
        this.scene.add(this.goalkeeper);
        this.goalkeeperAI = new GoalkeeperAI(this.goalkeeper, this.goalkeeperMixer, this.goalkeeperClips);

        this.createAimMarker();

        this.player.add(this.camera);
        this.scene.add(this.player);
        
        console.log('‚úÖ Elementos principales del juego construidos con m√°xima calidad');
    }

    createAimMarker() {
        const markerGroup = new THREE.Group();
        
        const outerRing = new THREE.Mesh(
            new THREE.RingGeometry(0.3, 0.35, 32),
            new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            })
        );
        
        const innerCircle = new THREE.Mesh(
            new THREE.CircleGeometry(0.3, 32),
            new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            })
        );
        
        const crossGeometry = new THREE.BufferGeometry();
        const crossVertices = new Float32Array([
            -0.15, 0, 0,  0.15, 0, 0,
            0, -0.15, 0,  0, 0.15, 0
        ]);
        crossGeometry.setAttribute('position', new THREE.BufferAttribute(crossVertices, 3));
        
        const crossLines = new THREE.LineSegments(
            crossGeometry,
            new THREE.LineBasicMaterial({ 
                color: 0xffff00,
                linewidth: 2
            })
        );
        
        markerGroup.add(outerRing);
        markerGroup.add(innerCircle);
        markerGroup.add(crossLines);
        
        markerGroup.position.set(0, 1.5, -14.95);
        markerGroup.visible = false;
        
        this.scene.add(markerGroup);
        this.aimMarker = markerGroup;
        
        gsap.to(outerRing.scale, {
            x: 1.2,
            y: 1.2,
            z: 1.2,
            duration: 0.8,
            ease: 'sine.inOut',
            yoyo: true,
            repeat: -1
        });
        
        console.log('üéØ Marcador de apuntado creado');
    }

    hideAimMarker() {
        if (this.aimMarker && this.aimMarkerVisible) {
            this.aimMarker.visible = false;
            this.aimMarkerVisible = false;
            console.log('üéØ Marcador de apuntado OCULTO');
        }
    }

    showAimMarker() {
        if (this.aimMarker && !this.aimMarkerVisible) {
            this.aimMarker.visible = true;
            this.aimMarkerVisible = true;
            console.log('üéØ Marcador de apuntado VISIBLE');
        }
    }

    handleGestureAim(target) {
        if (this.aimMarker && !this.aimMarkerVisible) {
            this.showAimMarker();
        }
        
        const goalWidth = 7.32;
        const goalHeight = 2.44;
        const goalZ = -14.95;
        
        const aimX = (1 - target.x - 0.5) * goalWidth * 0.9;
        const aimY = (1 - target.y) * goalHeight * 0.9 + 0.3;
        
        if (this.aimMarker) {
            gsap.to(this.aimMarker.position, {
                x: aimX,
                y: aimY,
                z: goalZ,
                duration: 0.15,
                ease: 'power2.out'
            });
        }
        
        const targetYaw = (target.x - 0.5) * Math.PI / 6;
        const targetPitch = -(target.y - 0.5) * Math.PI / 9;
        
        gsap.to(this.camera.rotation, {
            y: targetYaw,
            x: targetPitch,
            duration: 0.2,
            ease: 'power2.out'
        });
    }

    async activateGesturesOnStart() {
        console.log('ü¶∂ Auto-activando control con pie (PERMANENTE)...');
        
        try {
            const success = await this.gesture.init();
            
            if (success) {
                this.gestureControlActive = true;
                this.gesture.enable();
                console.log('‚úÖ Control con pie activado autom√°ticamente');
            } else {
                console.log('‚ùå Control con pie fall√≥, usando teclado de respaldo');
            }
        } catch (error) {
            console.error('Error activating gesture control:', error);
        }
    }

    resetScene() {
        this.player.position.set(0, 1.7, 10);
        this.camera.rotation.set(0, 0, 0);
        
        this.hideAimMarker();
        
        if (!this.player.children.includes(this.camera)) this.player.add(this.camera);
        this.toPlayerView();
        
        if (this.ball) {
            this.ball.position.set(0, 0.1, 0);
            this.ball.userData.velocity = new THREE.Vector3(0, 0, 0);
            console.log('‚öΩ Pelota reiniciada en posici√≥n:', this.ball.position);
        } else {
            console.warn('‚ö†Ô∏è ADVERTENCIA: No hay pelota en la escena');
        }
        
        if (this.goalkeeperAI) this.goalkeeperAI.reset();
        this.ui.reset();
        
        this.input.power = 0;
        this.input.charging = false;
        
        this.stateMachine.changeState('PRE_PENAL');
    }

    bindEventListeners() {
        console.log('üì° Binding event listeners...');
        
        this.ui.on('start', () => {
            console.log('üéÆ Start button pressed - initializing audio and gestures');
            this.audio.init(this.camera);
            this.audio.activateAudioContext();
            
            setTimeout(() => {
                this.audio.playStadiumAmbient();
            }, 500);
            
            if (!this.gestureControlActive) {
                this.activateGesturesOnStart();
            }
            
            setTimeout(() => {
                this.audio.ensureMontielReady();
            }, 1000);
            
            this.controls.lock();
            this.resetScene(); 
        });
        
        this.ui.on('retry', () => {
            this.resetScene();
            this.controls.lock();
        });

        this.input.on('kick', (power) => {
            if(this.stateMachine.currentState && this.stateMachine.currentState.name === 'AIMING') {
                if (this.stadium) {
                    this.stadium.intensifyAtmosphere();
                }
                
                this.audio.intensifyStadiumAudio();
                
                this.stateMachine.changeState('KICK', { power });
            }
        });

        this.input.on('test-audio', () => {
            console.log('Testing audio system...');
            this.audio.activateAudioContext();
            
            setTimeout(() => {
                this.audio.playMontiel();
            }, 500);
        });

        // LISTENERS PARA KICK GESTURE MANAGER
        this.gesture.on('pointing', (target) => {
            console.log('üéØ EVENTO POINTING DEL GESTO:', target);
            
            if (this.gestureControlActive && this.stateMachine.currentState?.name === 'AIMING') {
                this.handleGestureAim(target);
            }
        });
        
        this.gesture.on('charge-start', () => {
            console.log('‚ö° EVENTO CHARGE-START DEL GESTO');
            
            if (this.gestureControlActive && this.stateMachine.currentState?.name === 'AIMING') {
                if (!this.input.charging) {
                    this.input.charging = true;
                    this.input.power = 0;
                    gsap.to(this.input, { 
                        power: 1, 
                        duration: 1.5, 
                        ease: 'power1.in',
                        onUpdate: () => {
                            this.ui.updatePowerBar(this.input.power);
                        }
                    });
                }
            }
        });
        
        this.gesture.on('charging', (power) => {
            if (this.gestureControlActive && this.stateMachine.currentState?.name === 'AIMING') {
                this.input.power = power;
                this.ui.updatePowerBar(power * 100);
            }
        });
        
        this.gesture.on('shoot', (shotData) => {
            console.log('‚öΩ EVENTO SHOOT DEL GESTO:', shotData);
            
            if (this.gestureControlActive && this.stateMachine.currentState?.name === 'AIMING') {
                gsap.killTweensOf(this.input);
                
                const kickPower = shotData.power || this.input.power;
                
                console.log(`‚öΩ Disparando con potencia: ${(kickPower * 100).toFixed(0)}%`);
                
                this.hideAimMarker();
                this.input.charging = false;
                this.input.power = 0;
                
                if (this.stateMachine.currentState && this.stateMachine.currentState.name === 'AIMING') {
                    if (this.stadium) {
                        this.stadium.intensifyAtmosphere();
                    }
                    
                    this.audio.intensifyStadiumAudio();
                    
                    this.stateMachine.changeState('KICK', { power: kickPower });
                }
            }
        });

        this.controls.addEventListener('lock', () => this.ui.showHUD(true));
        this.controls.addEventListener('unlock', () => this.ui.showHUD(false));
    }

    update(deltaTime) {
        if(this.stateMachine.currentState) {
            this.stateMachine.currentState.update(deltaTime);
        }
        
        if (this.goalkeeperMixer) {
            this.goalkeeperMixer.update(deltaTime);
        }
        
        if (this.stateMachine.currentState && (this.stateMachine.currentState.name === 'KICK' || this.stateMachine.currentState.name === 'OUTCOME')) {
            this.camera.lookAt(this.cameraLookTarget);
        }

        this.renderer.render(this.scene, this.camera);
    }
    
    toPlayerView() {
        gsap.to(this.camera.position, { x: 0, y: 0, z: 0, duration: 0.5 });
        this.camera.lookAt(0, 1, -15);
    }

    toBallFollowView(ball) {
        const startPos = new THREE.Vector3();
        this.camera.getWorldPosition(startPos);
        
        this.player.remove(this.camera);
        this.scene.add(this.camera);
        this.camera.position.copy(startPos);

        this.cameraLookTarget.copy(ball.position);

        gsap.to(this.camera.position, {
            x: startPos.x, y: startPos.y + 1, z: startPos.z + 2,
            duration: 1.5
        });
        
        gsap.to(this.cameraLookTarget, {
            x: () => ball.position.x,
            y: () => Math.max(ball.position.y, 0.5),
            z: () => ball.position.z,
            duration: 3, 
            ease: "power2.out"
        });
    }

    toStadiumView() {
        gsap.to(this.camera.position, { x: 15, y: 10, z: -5, duration: 1 });
        gsap.to(this.cameraLookTarget, {
            x: this.goal.position.x,
            y: this.goal.position.y + 1,
            z: this.goal.position.z,
            duration: 1
        });
    }

    onResize() {
        this.sizes.width = window.innerWidth;
        this.sizes.height = window.innerHeight;
        this.camera.aspect = this.sizes.width / this.sizes.height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.sizes.width, this.sizes.height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}
</file>

</files>
