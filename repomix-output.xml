This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
index.html
package.json
public/vite.svg
README.md
src/counter.js
src/experience/Assets.js
src/experience/Audio.js
src/experience/GoalkeeperAI.js
src/experience/Input.js
src/experience/SceneManager.js
src/experience/ShotModel.js
src/experience/States.js
src/experience/UI.js
src/javascript.svg
src/main.js
src/style.css
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Penal - Final del Mundo</title>
    <link rel="stylesheet" href="./src/style.css">
</head>
<body>
    <canvas id="webgl"></canvas>
    
    <div id="ui-container">
        <!-- Pantalla de INTRO -->
        <div id="intro-overlay" class="overlay active">
            <h1>Final del Mundo</h1>
            <p>Minuto 120. El destino en tus pies.</p>
            <button id="start-button">Empezar</button>
        </div>

        <!-- HUD del juego -->
        <div id="hud" class="hidden">
            <div id="power-bar-container">
                <div id="power-bar"></div>
            </div>
            <div id="reticle">+</div>
            <div class="controls-info">
                <p>WASD: Moverse | MOUSE: Apuntar | ESPACIO: Cargar fuerza</p>
            </div>
        </div>
        
        <!-- Pantalla de EPILOGUE -->
        <div id="epilogue-overlay" class="overlay hidden">
            <h2 id="epilogue-title"></h2>
            <p id="epilogue-message">Un penal no es solo un disparo, es una historia.</p>
            <button id="retry-button">Reintentar</button>
        </div>

        <!-- Controles de Debug/Opciones -->
        <div id="options-panel">
             <label for="pressure-slider">Presión:</label>
             <input type="range" id="pressure-slider" min="0" max="1" step="0.1" value="0.3">
             <button id="view-toggle-button">Vista Fija</button>
        </div>
    </div>

    <script type="module" src="/src/main.js"></script>
</body>
</html>
</file>

<file path="package.json">
{
  "name": "final-penalty-kick",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "vite": "^7.1.2"
  },
  "dependencies": {
    "eventemitter3": "^5.0.1",
    "gsap": "^3.13.0",
    "three": "^0.180.0"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# Three.js - Penal de la Final del Mundo

Este proyecto es una simulación completa de un penal decisivo en una final del mundo, desarrollado con Three.js y Vite. La experiencia incluye movimiento en primera persona, una IA para el arquero, múltiples desenlaces y un arco narrativo.

## Requisitos

- Node.js (v16 o superior)
- npm

## Instalación y Ejecución

1.  **Clonar el repositorio:**
    ```bash
    git clone https://...
    cd final-penalty-kick
    ```

2.  **Colocar los assets (OBLIGATORIO):**
    Descarga los modelos 3D y los archivos de audio y colócalos en la carpeta `public/` siguiendo esta estructura:
    
    ```
    public/
    ├── models/
    │   ├── arco.glb
    │   ├── pelota.glb
    │   ├── jugador.glb
    │   └── arquero.glb
    └── audio/
        ├── crowd.mp3
        ├── heartbeat.mp3
        ├── goal.mp3
        ├── fail.mp3
        └── whistle.mp3
    ```

3.  **Instalar dependencias:**
    ```bash
    npm install
    ```

4.  **Iniciar el servidor de desarrollo:**
    ```bash
    npm run dev
    ```
    Abre la URL que aparece en la consola (generalmente `http://localhost:5173`).

## Controles

-   **WASD:** Mover al jugador en la fase de `PRE_PENAL`.
-   **Mouse:** Apuntar la dirección del tiro.
-   **A/D:** Perfilar el tiro (movimiento lateral sutil) en la fase de `AIMING`.
-   **Mantener ESPACIO:** Cargar la barra de fuerza.
-   **Soltar ESPACIO:** Patear la pelota.
-   **SHIFT (Opcional):** Correr en la fase de `PRE_PENAL`.

## Opciones en Pantalla

-   **Slider "Presión":** Aumenta la imprecisión del tiro. Un valor más alto hace más difícil anotar.
-   **Botón "Vista Fija / WASD":** (Funcionalidad por implementar) Permitiría alternar entre el movimiento libre y una cámara estática.

## Stack Tecnológico

-   **Motor 3D:** Three.js (r150+)
-   **Bundler:** Vite
-   **Animación:** GSAP
-   **Módulos de Three.js:** `GLTFLoader`, `PointerLockControls`
-   **Audio:** WebAudio API (gestionada a través de Three.js Audio)
</file>

<file path="src/counter.js">
export function setupCounter(element) {
  let counter = 0
  const setCounter = (count) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}
</file>

<file path="src/experience/Assets.js">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import EventEmitter from 'eventemitter3';

export default class Assets extends EventEmitter {
    constructor() {
        super();
        this.manager = new THREE.LoadingManager(
            () => this.emit('loaded'),
            (url, itemsLoaded, itemsTotal) => {
                const progress = itemsLoaded / itemsTotal;
                this.emit('progress', progress);
            }
        );
        this.gltfLoader = new GLTFLoader(this.manager);
        this.items = {};

        this.load();
    }

    load() {
        const modelsToLoad = [
            { name: 'arco', path: '/models/arco.glb' },
            { name: 'pelota', path: '/models/pelota.glb' },
            { name: 'jugador', path: '/models/jugador.glb' },
            { name: 'arquero', path: '/models/arquero.glb' },
            
        ];

        for (const model of modelsToLoad) {
            this.gltfLoader.load(model.path, (gltf) => {
                this.items[model.name] = gltf;
            });
        }
    }

    get(name) {
        return this.items[name];
    }
}
</file>

<file path="src/experience/Audio.js">
import * as THREE from 'three';
import gsap from 'gsap';

export default class AudioManager {
    constructor() {
        this.listener = null;
        this.sounds = {};
        this.audioSources = {
            crowd: '/audio/crowd.mp3',
            heartbeat: '/audio/heartbeat.mp3',
            goal: '/audio/goal.mp3',
            fail: '/audio/fail.mp3',
            whistle: '/audio/whistle.mp3',
        };
    }

    init() {
        // La creación del AudioContext debe estar tras un gesto del usuario
        this.listener = new THREE.AudioListener();
        const audioLoader = new THREE.AudioLoader();

        Object.entries(this.audioSources).forEach(([name, path]) => {
            const sound = new THREE.Audio(this.listener);
            this.sounds[name] = sound;
            audioLoader.load(path, (buffer) => {
                sound.setBuffer(buffer);
                sound.setVolume(0.5);
            });
        });
    }

    play(name, loop = false) {
        const sound = this.sounds[name];
        if (sound && !sound.isPlaying) {
            sound.setLoop(loop);
            sound.play();
        }
    }

    stop(name) {
        const sound = this.sounds[name];
        if (sound && sound.isPlaying) {
            sound.stop();
        }
    }

    fade(name, targetVolume, duration) {
        const sound = this.sounds[name];
        if (sound) {
            gsap.to(sound, { volume: targetVolume, duration: duration });
        }
    }
}
</file>

<file path="src/experience/GoalkeeperAI.js">
import * as THREE from 'three';
import gsap from 'gsap';

export default class GoalkeeperAI {
    constructor(model) {
        this.model = model;
        this.initialPos = model.position.clone();
        this.state = 'IDLE'; // IDLE, ANTICIPATE, DIVE
        this.reactionTime = 0.25;

        // --- CAMBIO CLAVE: Zonas de atajada predefinidas ---
        // Estas son las "decisiones" que el arquero puede tomar.
        const goalWidth = 2.3;
        const goalHeight = 2.0;
        this.diveZones = [
            new THREE.Vector3(-goalWidth, goalHeight, this.initialPos.z), // Arriba izquierda
            new THREE.Vector3(0, goalHeight, this.initialPos.z),          // Arriba centro
            new THREE.Vector3(goalWidth, goalHeight, this.initialPos.z),  // Arriba derecha
            new THREE.Vector3(-goalWidth, 0.5, this.initialPos.z),       // Abajo izquierda
            new THREE.Vector3(goalWidth, 0.5, this.initialPos.z),        // Abajo derecha
            new THREE.Vector3(0, 0.5, this.initialPos.z),                // Abajo centro (quédate quieto)
        ];
        
        this.reset();
    }

    reset() {
        gsap.killTweensOf(this.model.position);
        gsap.killTweensOf(this.model.rotation);
        this.model.position.copy(this.initialPos);
        this.model.rotation.set(0, 0, 0); 
        this.state = 'IDLE';
        this.startIdleAnimation();
    }
    
    startIdleAnimation() {
        gsap.to(this.model.position, {
            x: this.initialPos.x + (Math.random() > 0.5 ? 0.3 : -0.3),
            duration: 1.5 + Math.random(),
            ease: 'power1.inOut',
            yoyo: true,
            repeat: -1
        });
    }

    /**
     * @param {THREE.Vector3} targetPoint - Ya no usamos este parámetro. El arquero adivina.
     */
    reactToShot(targetPoint) {
        this.state = 'ANTICIPATE';
        gsap.killTweensOf(this.model.position); 

        // --- LÓGICA COMPLETAMENTE NUEVA ---
        // El arquero elige aleatoriamente una zona a la que tirarse, ¡como en la vida real!
        const randomIndex = Math.floor(Math.random() * this.diveZones.length);
        const diveTarget = this.diveZones[randomIndex];
        
        setTimeout(() => this.dive(diveTarget), this.reactionTime * 1000);
    }
    
    dive(target) {
        this.state = 'DIVE';
        
        gsap.to(this.model.position, {
            x: target.x,
            y: target.y,
            duration: 0.4,
            ease: 'power2.out'
        });
        
        // No te tires si te quedas en el centro
        if (target.x !== 0 || target.y > 0.5) {
            const direction = target.x > this.initialPos.x ? -1 : 1;
            gsap.to(this.model.rotation, {
                z: direction * Math.PI / 4, 
                duration: 0.35,
                ease: 'power2.out'
            });
        }
    }
    
    checkSave(ballPosition) {
        if (this.state !== 'DIVE') return false;
        
        const saveVolume = new THREE.Box3().setFromObject(this.model);
        // --- CAMBIO SUTIL: Reducimos un poco el hitbox para que sea más justo ---
        saveVolume.expandByScalar(0.0);
        
        return saveVolume.containsPoint(ballPosition);
    }
}
</file>

<file path="src/experience/Input.js">
import EventEmitter from 'eventemitter3';
import gsap from 'gsap';

export default class InputManager extends EventEmitter {
    constructor() {
        super();
        this.keys = {
            w: false, a: false, s: false, d: false,
            shift: false, space: false
        };
        this.power = 0;
        this.charging = false;
        this.movementEnabled = false;

        // --- CAMBIO CRUCIAL AQUÍ ---
        // Cambiamos 'window' por 'document' para asegurar que los eventos se capturen
        // incluso cuando el puntero del mouse está bloqueado.
        document.addEventListener('keydown', (e) => this.onKey(e.code, true));
        document.addEventListener('keyup', (e) => this.onKey(e.code, false));
    }
    
    setMovementEnabled(enabled) {
        this.movementEnabled = enabled;
    }

    onKey(code, isPressed) {
        // Para depuración, puedes descomentar la siguiente línea:
        // console.log(`Key Event -> Code: ${code}, Pressed: ${isPressed}`);

        switch(code) {
            case 'KeyW':
            case 'ArrowUp':
                if (this.movementEnabled) this.keys.w = isPressed;
                break;
            case 'KeyA':
            case 'ArrowLeft':
                // La 'A' y 'D' deben funcionar tanto para moverse como para perfilarse
                this.keys.a = isPressed;
                break;
            case 'KeyS':
            case 'ArrowDown':
                if (this.movementEnabled) this.keys.s = isPressed;
                break;
            case 'KeyD':
            case 'ArrowRight':
                // La 'A' y 'D' deben funcionar tanto para moverse como para perfilarse
                this.keys.d = isPressed;
                break;
            case 'ShiftLeft':
                this.keys.shift = isPressed;
                break;
            case 'Space':
                this.handleSpace(isPressed);
                break;
        }
    }

    handleSpace(isPressed) {
        if (isPressed && !this.charging) {
            // Iniciar carga solo si estamos en el estado de apuntado (AIMING)
            // Esto lo controlará la máquina de estados, aquí solo registramos la pulsación.
            this.charging = true;
            this.power = 0;
            gsap.to(this, { power: 1, duration: 1.5, ease: 'power1.in' });
        } else if (!isPressed && this.charging) {
            // Soltar y patear
            this.charging = false;
            gsap.killTweensOf(this); // Detiene la animación de carga
            this.emit('kick', this.power);
            this.power = 0;
        }
    }
}
</file>

<file path="src/experience/SceneManager.js">
import * as THREE from 'three';
import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import gsap from 'gsap';

import Assets from './Assets';
import StateMachine from './States';
import InputManager from './Input';
import AudioManager from './Audio';
import UIManager from './UI';
import GoalkeeperAI from './GoalkeeperAI';
import ShotModel from './ShotModel';

export default class SceneManager {
    constructor(canvas) {
        this.canvas = canvas;
        this.sizes = { width: window.innerWidth, height: window.innerHeight };
        
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, this.sizes.width / this.sizes.height, 0.1, 100);
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
        this.renderer.setSize(this.sizes.width, this.sizes.height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;

        this.assets = new Assets();
        this.input = new InputManager();
        this.ui = new UIManager();
        this.audio = new AudioManager();
        this.stateMachine = new StateMachine(this);
        this.shotModel = new ShotModel();

        this.player = new THREE.Group();
        this.ball = null;
        this.goalkeeper = null;
        this.goal = null;
        this.cameraLookTarget = new THREE.Vector3(); 

        this.controls = new PointerLockControls(this.camera, document.body);
        this.goalkeeperAI = null;

        this.init();
    }

    init() {
        this.setupScene();
        this.bindEventListeners();
        
        this.assets.on('loaded', () => {
            this.buildWorld();
            this.stateMachine.changeState('INTRO');
        });
    }

    setupScene() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffffff, 1, 100, Math.PI * 0.2, 0.5);
        spotLight.position.set(0, 15, 0); 
        spotLight.castShadow = true;
        this.scene.add(spotLight);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({ color: 0x2d6a2b }) 
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        this.scene.add(ground);

        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const spotGeometry = new THREE.CircleGeometry(0.1, 32);
        const penaltySpot = new THREE.Mesh(spotGeometry, lineMaterial);
        penaltySpot.rotation.x = -Math.PI / 2;
        penaltySpot.position.y = 0.01; 
        this.scene.add(penaltySpot);
    }
    
    buildWorld() {
        const goalModel = this.assets.get('arco');
        this.goal = goalModel.scene;
        this.goal.position.set(0, 0, -15);
        this.goal.scale.set(3, 3, 3);
        this.scene.add(this.goal);

        const ballModel = this.assets.get('pelota');
        this.ball = ballModel.scene;
        this.ball.scale.set(0.1, 0.1, 0.1);
        this.ball.castShadow = true;
        this.scene.add(this.ball);
        
        const keeperModel = this.assets.get('arquero');
        this.goalkeeper = keeperModel.scene;
        this.goalkeeper.position.set(0, 0, -14.8);
        this.goalkeeper.scale.set(1.5, 1.5, 1.5);
        this.scene.add(this.goalkeeper);
        this.goalkeeperAI = new GoalkeeperAI(this.goalkeeper);

        this.player.add(this.camera);
        this.scene.add(this.player);
    }

    resetScene() {
        this.player.position.set(0, 1.7, 8);
        this.camera.rotation.set(0, 0, 0);
        
        if (!this.player.children.includes(this.camera)) this.player.add(this.camera);
        this.toPlayerView();
        
        if (this.ball) {
            this.ball.position.set(0, 0.1, 0); 
            if (this.ball.userData.velocity) this.ball.userData.velocity.set(0,0,0);
        }
        
        if (this.goalkeeperAI) this.goalkeeperAI.reset();
        this.ui.reset();
        this.stateMachine.changeState('PRE_PENAL');
    }

    bindEventListeners() {
        // --- CAMBIO CLAVE AQUÍ: Se eliminó el parámetro (e) para que coincida con el emit() de UI.js ---
        this.ui.on('start', () => {
            this.audio.init(); 
            this.audio.play('crowd', true);
            this.controls.lock();
            this.resetScene(); 
        });
        
        this.ui.on('retry', () => {
            this.resetScene();
            this.controls.lock();
        });

        this.input.on('kick', (power) => {
            if(this.stateMachine.currentState && this.stateMachine.currentState.name === 'AIMING') {
                this.stateMachine.changeState('KICK', { power });
            }
        });

        this.controls.addEventListener('lock', () => this.ui.showHUD(true));
        this.controls.addEventListener('unlock', () => this.ui.showHUD(false));
    }

    update(deltaTime) {
        if(this.stateMachine.currentState) {
            this.stateMachine.currentState.update(deltaTime);
        }
        
        if (this.stateMachine.currentState && (this.stateMachine.currentState.name === 'KICK' || this.stateMachine.currentState.name === 'OUTCOME')) {
            this.camera.lookAt(this.cameraLookTarget);
        }

        this.renderer.render(this.scene, this.camera);
    }
    
    toPlayerView() {
        gsap.to(this.camera.position, { x: 0, y: 0, z: 0, duration: 0.5 });
        this.camera.lookAt(0, 1, -15);
    }

    toBallFollowView(ball) {
        const startPos = new THREE.Vector3();
        this.camera.getWorldPosition(startPos);
        
        this.player.remove(this.camera);
        this.scene.add(this.camera);
        this.camera.position.copy(startPos);

        this.cameraLookTarget.copy(ball.position);

        gsap.to(this.camera.position, {
            x: startPos.x, y: startPos.y + 1, z: startPos.z + 2,
            duration: 1.5
        });
        
        gsap.to(this.cameraLookTarget, {
            x: () => ball.position.x,
            y: () => Math.max(ball.position.y, 0.5),
            z: () => ball.position.z,
            duration: 3, 
            ease: "power2.out"
        });
    }

    toStadiumView() {
        gsap.to(this.camera.position, { x: 15, y: 10, z: -5, duration: 1 });
        gsap.to(this.cameraLookTarget, {
            x: this.goal.position.x,
            y: this.goal.position.y + 1,
            z: this.goal.position.z,
            duration: 1
        });
    }

    onResize() {
        this.sizes.width = window.innerWidth;
        this.sizes.height = window.innerHeight;
        this.camera.aspect = this.sizes.width / this.sizes.height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.sizes.width, this.sizes.height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }
}
</file>

<file path="src/experience/ShotModel.js">
import * as THREE from 'three';

export default class ShotModel {
    constructor() {
        this.maxPowerSpeed = 50;
        this.liftFactor = 0.25; // Podemos darle un buen efecto de elevación
    }

    calculateTrajectory(cameraRotation, power, pressure) {
        // --- LÓGICA DE FÍSICA COMPLETAMENTE REESCRITA (Y SIMPLIFICADA) ---

        // 1. Definimos la elevación del disparo basado en la potencia.
        const liftAmount = power * this.liftFactor;
        
        // 2. Creamos un vector de dirección base EN ESPACIO DE CÁMARA.
        // Ya está apuntando hacia adelante (-Z) y hacia arriba (+Y).
        let direction = new THREE.Vector3(0, liftAmount, -1);
        
        // 3. NORMALIZAMOS el vector. ¡Este paso es CRUCIAL!
        // Asegura que el vector tiene una longitud de 1, para que la velocidad sea consistente.
        direction.normalize();

        // 4. AHORA rotamos este vector perfecto al espacio del mundo, según donde mira el jugador.
        direction.applyEuler(cameraRotation);
        
        // 5. Añadimos la imprecisión por presión (esto no cambia)
        const noiseX = (Math.random() - 0.5) * pressure * 0.2;
        const noiseY = (Math.random() - 0.5) * pressure * 0.15;
        direction.x += noiseX;
        direction.y += noiseY;
        
        // 6. Calculamos la velocidad final
        const initialSpeed = this.maxPowerSpeed * power;
        const initialVelocity = direction.clone().multiplyScalar(initialSpeed);

        // El resto es para la IA, no afecta la trayectoria real
        const distanceToGoal = 15;
        const timeToGoal = Math.abs(distanceToGoal / initialVelocity.z);
        const targetPoint = new THREE.Vector3(
            initialVelocity.x * timeToGoal,
            0.1 + initialVelocity.y * timeToGoal - 0.5 * 9.8 * timeToGoal * timeToGoal,
            -distanceToGoal
        );

        return { initialVelocity, targetPoint };
    }
}
</file>

<file path="src/experience/States.js">
import * as THREE from 'three';
import gsap from 'gsap';

const PENALTY_SPOT = new THREE.Vector3(0, 0, 0);
const PLAYER_AREA_RADIUS = 9; 
const GRAVITY = 9.8;

class State {
    constructor(name, manager) {
        this.name = name;
        this.manager = manager;
    }
    enter(params) {}
    update(deltaTime) {}
    exit() {}
}

class IntroState extends State {
    enter() { this.manager.ui.showIntro(true); }
    exit() { this.manager.ui.showIntro(false); }
}

class PrePenalState extends State {
    enter() {
        this.manager.audio.fade('heartbeat', 0.5, 2);
        this.manager.input.setMovementEnabled(true);
    }
    update(deltaTime) {
        const moveSpeed = this.manager.input.keys.shift ? 6.0 : 3.0;
        const moveDirection = new THREE.Vector3();

        if (this.manager.input.keys.w) moveDirection.z -= 1;
        if (this.manager.input.keys.s) moveDirection.z += 1;
        if (this.manager.input.keys.a) moveDirection.x -= 1;
        if (this.manager.input.keys.d) moveDirection.x += 1;

        if (moveDirection.length() > 0) {
            moveDirection.normalize().multiplyScalar(moveSpeed * deltaTime);
            const yRotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, this.manager.camera.rotation.y, 0));
            moveDirection.applyQuaternion(yRotation);
            
            const nextPosition = this.manager.player.position.clone().add(moveDirection);
            
            if (nextPosition.distanceTo(PENALTY_SPOT) < PLAYER_AREA_RADIUS) {
                 this.manager.player.position.add(moveDirection);
            }
        }
        
        const playerPos2D = new THREE.Vector2(this.manager.player.position.x, this.manager.player.position.z);
        const ballPos2D = new THREE.Vector2(this.manager.ball.position.x, this.manager.ball.position.z);
        
        if (playerPos2D.distanceTo(ballPos2D) < 2.5) {
            this.manager.stateMachine.changeState('AIMING');
        }
    }
    exit() { this.manager.input.setMovementEnabled(false); }
}

class AimingState extends State {
    update(deltaTime) {
        const profileSpeed = 1.0;
        if (this.manager.input.keys.a) this.manager.player.position.x -= profileSpeed * deltaTime;
        if (this.manager.input.keys.d) this.manager.player.position.x += profileSpeed * deltaTime;
        
        this.manager.player.position.x = THREE.MathUtils.clamp(this.manager.player.position.x, -1.5, 1.5);
        this.manager.ui.updatePowerBar(this.manager.input.power);
    }
}

class KickState extends State {
    constructor(name, manager) {
        super(name, manager);
        this.hasCheckedOutcome = false;
    }

    enter(params) {
        this.hasCheckedOutcome = false;
        this.manager.audio.play('whistle');
        this.manager.audio.fade('heartbeat', 0, 0.5);
        this.manager.ui.showHUD(false);
        this.manager.input.power = 0; 

        const pressure = this.manager.ui.getPressure();
        const shotData = this.manager.shotModel.calculateTrajectory(
            this.manager.camera.rotation, params.power, pressure
        );
        
        this.manager.ball.userData.velocity = shotData.initialVelocity;
        this.manager.ball.userData.targetPoint = shotData.targetPoint;

        this.manager.toBallFollowView(this.manager.ball);
        this.manager.goalkeeperAI.reactToShot(shotData.targetPoint);
        
        gsap.to(this.manager.camera.position, { z: this.manager.camera.position.z - 0.2, yoyo: true, repeat: 1, duration: 0.1 });
    }

    update(deltaTime) {
        if (!this.manager.ball.userData.velocity) return;

        this.manager.ball.position.add(this.manager.ball.userData.velocity.clone().multiplyScalar(deltaTime));
        this.manager.ball.userData.velocity.y -= GRAVITY * deltaTime;
        
        const GOAL_LINE_Z = -15; 
        if (this.manager.ball.position.z <= GOAL_LINE_Z && !this.hasCheckedOutcome) {
            this.checkOutcome();
        }
    }

    // --- FUNCIÓN COMPLETAMENTE REESCRITA ---
    checkOutcome() {
        this.hasCheckedOutcome = true;
        const ballPos = this.manager.ball.position;
        const goalWidth = 4.6; 
        const goalHeight = 2.44;

        // 1. ¿La atajó el arquero?
        if (this.manager.goalkeeperAI.checkSave(ballPos)) {
            this.manager.stateMachine.changeState('OUTCOME', { result: 'save' });
        
        // 2. ¿Se fue afuera (palo, travesaño o desviado)?
        } else if (Math.abs(ballPos.x) > goalWidth / 2 || ballPos.y > goalHeight || ballPos.y < 0) {
            this.manager.stateMachine.changeState('OUTCOME', { result: 'post' }); // Usamos 'post' para todos los fallos

        // 3. Si no fue atajada y no se fue afuera, ¡es GOL!
        } else {
            this.manager.stateMachine.changeState('OUTCOME', { result: 'goal' });
        }
    }
    
    exit() {
        if(this.manager.ball.userData.velocity) this.manager.ball.userData.velocity.set(0,0,0);
    }
}

class OutcomeState extends State {
    enter(params) {
        switch(params.result) {
            case 'goal':
                this.manager.audio.play('goal');
                this.manager.audio.fade('crowd', 1, 1);
                this.manager.toStadiumView();
                setTimeout(() => this.manager.stateMachine.changeState('EPILOGUE', { title: "¡GOOOOL!" }), 2000);
                break;
            case 'save':
            case 'post': // Ahora 'post' cubre todos los fallos
                this.manager.audio.play('fail');
                this.manager.audio.fade('crowd', 0.2, 1);
                gsap.to(this.manager.ball.position, { 
                    x: this.manager.ball.position.x * 1.1, y: this.manager.ball.position.y * 0.5,
                    z: this.manager.ball.position.z - 1, duration: 1
                });
                setTimeout(() => this.manager.stateMachine.changeState('EPILOGUE', { title: "¡Fallado!" }), 2000);
                break;
            // El caso 'fail' ya no es necesario, lo cubre 'post'
        }
    }
}

class EpilogueState extends State {
    enter(params) {
        this.manager.ui.showEpilogue(true, params.title);
        this.manager.controls.unlock();
    }
    exit() { this.manager.ui.showEpilogue(false); }
}


export default class StateMachine {
    constructor(manager) {
        this.manager = manager;
        this.states = {
            'INTRO': new IntroState('INTRO', manager),
            'PRE_PENAL': new PrePenalState('PRE_PENAL', manager),
            'AIMING': new AimingState('AIMING', manager),
            'KICK': new KickState('KICK', manager),
            'OUTCOME': new OutcomeState('OUTCOME', manager),
            'EPILOGUE': new EpilogueState('EPILOGUE', manager),
        };
        this.currentState = null;
    }

    changeState(name, params) {
        if (this.currentState) this.currentState.exit();
        this.currentState = this.states[name];
        this.currentState.enter(params);
    }

    update(deltaTime) {
        if (this.currentState) this.currentState.update(deltaTime);
    }
}
</file>

<file path="src/experience/UI.js">
import EventEmitter from 'eventemitter3';

export default class UIManager extends EventEmitter {
    constructor() {
        super();
        this.introOverlay = document.getElementById('intro-overlay');
        this.epilogueOverlay = document.getElementById('epilogue-overlay');
        this.hud = document.getElementById('hud');
        this.powerBar = document.getElementById('power-bar');
        this.pressureSlider = document.getElementById('pressure-slider');
        
        // --- CAMBIO CLAVE AQUÍ ---
        // Añadimos el evento 'e' para poder acceder al botón que fue clickeado.
        document.getElementById('start-button').addEventListener('click', (e) => {
            this.emit('start');
            e.target.blur(); // Le quitamos el foco al botón para que no intercepte la barra espaciadora.
        });
        
        document.getElementById('retry-button').addEventListener('click', (e) => {
            this.emit('retry');
            e.target.blur(); // Hacemos lo mismo para el botón de reintentar.
        });
        
        // TODO: Lógica para el botón 'view-toggle-button'
    }

    showIntro(visible) {
        this.introOverlay.classList.toggle('hidden', !visible);
        this.introOverlay.classList.toggle('active', visible);
    }
    
    showHUD(visible) {
        this.hud.classList.toggle('hidden', !visible);
    }

    showEpilogue(visible, title = "") {
        document.getElementById('epilogue-title').innerText = title;
        this.epilogueOverlay.classList.toggle('hidden', !visible);
        this.epilogueOverlay.classList.toggle('active', visible);
    }

    updatePowerBar(power) {
        this.powerBar.style.width = `${power * 100}%`;
    }

    getPressure() {
        return parseFloat(this.pressureSlider.value);
    }
    
    reset() {
        this.showHUD(true);
        this.showEpilogue(false);
    }
}
</file>

<file path="src/javascript.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="32" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path fill="#F7DF1E" d="M0 0h256v256H0V0Z"></path><path d="m67.312 213.932l19.59-11.856c3.78 6.701 7.218 12.371 15.465 12.371c7.905 0 12.89-3.092 12.89-15.12v-81.798h24.057v82.138c0 24.917-14.606 36.259-35.916 36.259c-19.245 0-30.416-9.967-36.087-21.996m85.07-2.576l19.588-11.341c5.157 8.421 11.859 14.607 23.715 14.607c9.969 0 16.325-4.984 16.325-11.858c0-8.248-6.53-11.17-17.528-15.98l-6.013-2.58c-17.357-7.387-28.87-16.667-28.87-36.257c0-18.044 13.747-31.792 35.228-31.792c15.294 0 26.292 5.328 34.196 19.247l-18.732 12.03c-4.125-7.389-8.591-10.31-15.465-10.31c-7.046 0-11.514 4.468-11.514 10.31c0 7.217 4.468 10.14 14.778 14.608l6.014 2.577c20.45 8.765 31.963 17.7 31.963 37.804c0 21.654-17.012 33.51-39.867 33.51c-22.339 0-36.774-10.654-43.819-24.574"></path></svg>
</file>

<file path="src/main.js">
import * as THREE from 'three';
import SceneManager from './experience/SceneManager';

const canvas = document.querySelector('#webgl');
const sceneManager = new SceneManager(canvas);

const clock = new THREE.Clock();

function animate() {
    const deltaTime = clock.getDelta();
    sceneManager.update(deltaTime);
    requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', () => sceneManager.onResize());
</file>

<file path="src/style.css">
body, html { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: 'Helvetica', sans-serif; }
#webgl { position: fixed; top: 0; left: 0; outline: none; }
#ui-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; color: white; pointer-events: none; }

.overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.7);
    text-align: center;
    transition: opacity 1s ease;
}
.overlay.active { opacity: 1; pointer-events: all; }
.overlay.hidden { opacity: 0; pointer-events: none; }
.overlay h1 { font-size: 4rem; margin: 0; }
.overlay h2 { font-size: 3rem; text-shadow: 0 0 10px #fff; }
.overlay p { font-size: 1.5rem; }
.overlay button {
    padding: 15px 30px;
    font-size: 1.2rem;
    background: #fff;
    color: #000;
    border: none;
    cursor: pointer;
    margin-top: 20px;
    pointer-events: all;
    transition: background 0.3s;
}
.overlay button:hover { background: #ccc; }

#hud { width: 100%; height: 100%; }
#power-bar-container {
    position: absolute;
    bottom: 50px;
    left: 50%;
    transform: translateX(-50%);
    width: 300px;
    height: 20px;
    background: rgba(0,0,0,0.5);
    border: 2px solid white;
    padding: 2px;
}
#power-bar {
    width: 0%;
    height: 100%;
    background: linear-gradient(90deg, #adff2f, #ffff00, #ff4500);
}
#reticle {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    opacity: 0.5;
}
.controls-info {
    position: absolute;
    bottom: 10px;
    left: 10px;
    opacity: 0.7;
}

#options-panel {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 5px;
    pointer-events: all;
}
</file>

</files>
